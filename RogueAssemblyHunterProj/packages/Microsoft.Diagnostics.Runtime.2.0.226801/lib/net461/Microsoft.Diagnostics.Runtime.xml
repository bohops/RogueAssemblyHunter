<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.Diagnostics.Runtime</name>
    </assembly>
    <members>
        <member name="T:Microsoft.Diagnostics.Runtime.Architecture">
            <summary>
            The architecture of a process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Unknown">
            <summary>
            Unknown.  Should never be exposed except in case of error.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.X86">
            <summary>
            x86.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Amd64">
            <summary>
            x64
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Arm">
            <summary>
            ARM
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Architecture.Arm64">
            <summary>
            ARM64
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CacheOptions.MaxDumpCacheSize">
            <summary>
            The maximum amount of memory (virtual address space) used by data readers to cache
            memory from the dumpfile.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CacheOptions.UseOSMemoryFeatures">
            <summary>
            Whether or not to attempt to use special OS memory features such as AWE on
            Windows.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrAppDomain">
            <summary>
            Represents an AppDomain in the target runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Runtime">
            <summary>
            Gets the runtime associated with this ClrAppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Address">
            <summary>
            Gets address of the AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Id">
            <summary>
            Gets the AppDomain's ID.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Name">
            <summary>
            Gets the name of the AppDomain, as specified when the domain was created.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.Modules">
            <summary>
            Gets a list of modules loaded into this AppDomain.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.ConfigurationFile">
            <summary>
            Gets the config file used for the AppDomain.  This may be <see langword="null"/> if there was no config file
            loaded, or if the targeted runtime does not support enumerating that data.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrAppDomain.ApplicationBase">
            <summary>
            Gets the base directory for this AppDomain.  This may return <see langword="null"/> if the targeted runtime does
            not support enumerating this information.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrAppDomain.ToString">
            <summary>
            To string override.
            </summary>
            <returns>The name of this AppDomain.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrArray">
            <summary>
            Represents an array in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrArray.Address">
            <summary>
            Gets the address of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrArray.Type">
            <summary>
            Gets the type of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrArray.Length">
            <summary>
            Gets the count of elements in this array.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrArray.ReadValues``1(System.Int32,System.Int32)">
            <summary>
            Gets <paramref name="count"/> element values from the array.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrArray.Equals(System.Object)">
            <summary>
            Determines whether this instance and another specific <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> have the same value.
            <para>Instances are considered equal when they have the same <see cref="P:Microsoft.Diagnostics.Runtime.ClrArray.Address"/>.</para>
            </summary>
            <param name="obj">The <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> to compare to this instance.</param>
            <returns><see langword="true"/> if the <see cref="P:Microsoft.Diagnostics.Runtime.ClrArray.Address"/> of the parameter is the same as <see cref="P:Microsoft.Diagnostics.Runtime.ClrArray.Address"/> in this instance; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrArray.Equals(Microsoft.Diagnostics.Runtime.ClrArray)">
            <summary>
            Determines whether this instance and another specific <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> have the same value.
            <para>Instances are considered equal when they have the same <see cref="P:Microsoft.Diagnostics.Runtime.ClrArray.Address"/>.</para>
            </summary>
            <param name="other">The <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> to compare to this instance.</param>
            <returns><see langword="true"/> if the <see cref="P:Microsoft.Diagnostics.Runtime.ClrArray.Address"/> of the parameter is the same as <see cref="P:Microsoft.Diagnostics.Runtime.ClrArray.Address"/> in this instance; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrArray.Equals(Microsoft.Diagnostics.Runtime.ClrObject)">
            <summary>
            Determines whether this instance and a specified object.
            </summary>
            <param name="other">The <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject"/> to compare to this instance.</param>
            <returns>
            <see langword="true"/> if <paramref name="other"/> is <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject"/>, and its <see cref="P:Microsoft.Diagnostics.Runtime.ClrArray.Address"/> is the same as <see cref="P:Microsoft.Diagnostics.Runtime.ClrArray.Address"/> in this instance; <see langword="false"/>
            otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrArray.GetHashCode">
            <summary>
            Returns the hash code for this <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/>.
            </summary>
            <returns>An <see cref="T:System.Int32"/> hash code for this instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrArray.op_Equality(Microsoft.Diagnostics.Runtime.ClrArray,Microsoft.Diagnostics.Runtime.ClrArray)">
            <summary>
            Determines whether two specified <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> have the same value.
            </summary>
            <param name="left">First <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> to compare.</param>
            <param name="right">Second <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> to compare.</param>
            <returns><see langword="true"/> if <paramref name="left"/> <see cref="M:Microsoft.Diagnostics.Runtime.ClrArray.Equals(Microsoft.Diagnostics.Runtime.ClrArray)"/> <paramref name="right"/>; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrArray.op_Inequality(Microsoft.Diagnostics.Runtime.ClrArray,Microsoft.Diagnostics.Runtime.ClrArray)">
            <summary>
            Determines whether two specified <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> have different values.
            </summary>
            <param name="left">First <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> to compare.</param>
            <param name="right">Second <see cref="T:Microsoft.Diagnostics.Runtime.ClrArray"/> to compare.</param>
            <returns><see langword="true"/> if the value of <paramref name="left"/> is different from the value of <paramref name="right"/>; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException">
            <summary>
            Exception thrown by Microsoft.Diagnostics.Runtime unless there is a more appropriate
            exception subclass.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.#ctor(System.String)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.#ctor(System.String,System.Exception)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrDiagnosticsException.#ctor(System.String,System.Int32)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrDiagnosticsExceptionKind">
            <summary>
            Exception kind
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsExceptionKind.Unknown">
            <summary>
            Unknown error occurred.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsExceptionKind.CorruptedFileOrUnknownFormat">
            <summary>
            Dump file is corrupted or has an unknown format.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsExceptionKind.RevisionMismatch">
            <summary>
            The caller attempted to re-use an object after calling <see cref="M:Microsoft.Diagnostics.Runtime.ClrRuntime.FlushCachedData"/>.  See the
            documentation for <see cref="M:Microsoft.Diagnostics.Runtime.ClrRuntime.FlushCachedData"/> for more details.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsExceptionKind.DebuggerError">
            <summary>
            Something unexpected went wrong with the debugger we used to attach to the process or load the crash dump.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsExceptionKind.CrashDumpError">
            <summary>
            An error occurred while processing the given crash dump.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsExceptionKind.DataRequestError">
            <summary>
            Something unexpected went wrong when requesting data from the target process.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsExceptionKind.DacError">
            <summary>
            Hit an unexpected (non-recoverable) DAC error.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrDiagnosticsExceptionKind.RuntimeUninitialized">
            <summary>
            The dll of the specified runtime (<i>mscorwks.dll</i> or <i>clr.dll</i>) is loaded into the process, but
            has not actually been initialized and thus cannot be debugged.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrElementType">
            <summary>
            This is a representation of the metadata element type.  These values
            directly correspond with CLR's CorElementType.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Unknown">
            <summary>
            Not one of the other types.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Void">
            <summary>
            Void type.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Boolean">
            <summary>
            ELEMENT_TYPE_BOOLEAN
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Char">
            <summary>
            ELEMENT_TYPE_CHAR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int8">
            <summary>
            ELEMENT_TYPE_I1
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt8">
            <summary>
            ELEMENT_TYPE_U1
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int16">
            <summary>
            ELEMENT_TYPE_I2
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt16">
            <summary>
            ELEMENT_TYPE_U2
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int32">
            <summary>
            ELEMENT_TYPE_I4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt32">
            <summary>
            ELEMENT_TYPE_U4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Int64">
            <summary>
            ELEMENT_TYPE_I8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.UInt64">
            <summary>
            ELEMENT_TYPE_U8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Float">
            <summary>
            ELEMENT_TYPE_R4
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Double">
            <summary>
            ELEMENT_TYPE_R8
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.String">
            <summary>
            ELEMENT_TYPE_STRING
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Pointer">
            <summary>
            ELEMENT_TYPE_PTR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Struct">
            <summary>
            ELEMENT_TYPE_VALUETYPE
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Class">
            <summary>
            ELEMENT_TYPE_CLASS
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Var">
            <summary>
            ELEMENT_TYPE_VAR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Array">
            <summary>
            ELEMENT_TYPE_ARRAY
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.GenericInstantiation">
            <summary>
            ELEMENT_TYPE_GENERICINST
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.NativeInt">
            <summary>
            ELEMENT_TYPE_I
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.NativeUInt">
            <summary>
            ELEMENT_TYPE_U
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.FunctionPointer">
            <summary>
            ELEMENT_TYPE_FNPTR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.Object">
            <summary>
            ELEMENT_TYPE_OBJECT
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.MVar">
            <summary>
            ELEMENT_TYPE_MVAR
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrElementType.SZArray">
            <summary>
            ELEMENT_TYPE_SZARRAY
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrException">
            <summary>
            A wrapper for exception objects which help with common tasks for exception objects.
            Create this using <see cref="M:Microsoft.Diagnostics.Runtime.ClrObject.AsException"/>. You may call that when <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.IsException"/>
            is <see langword="true"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Thread">
            <summary>
            Gets the original thread this exception was thrown from.  This may be <see langword="null"/> if we do not know.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrException.AsObject">
            <summary>
            Returns this exception's ClrObject representation.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Address">
            <summary>
            Gets the address of the exception object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Type">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> for this exception object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Message">
            <summary>
            Gets the exception message.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.Inner">
            <summary>
            Gets the inner exception, if one exists, <see langword="null"/> otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.HResult">
            <summary>
            Gets the HRESULT associated with this exception (or S_OK if there isn't one).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrException.StackTrace">
            <summary>
            Gets the StackTrace for this exception.  Note that this may be empty or partial depending
            on the state of the exception in the process.  (It may have never been thrown or we may be in
            the middle of constructing the stackwalk.)  This returns an empty list if no stack trace is
            associated with this exception object.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrField">
            <summary>
            A representation of a field in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.ContainingType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> containing this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Name">
            <summary>
            Gets the name of the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Token">
            <summary>
            Gets the type token of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Type">
            <summary>
            Gets the type of the field.  Note this property may return <see langword="null"/> on error.  There is a bug in several versions
            of our debugging layer which causes this.  You should always null-check the return value of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.ElementType">
            <summary>
            Gets the element type of this field.  Note that even when Type is <see langword="null"/>, this should still tell you
            the element type of the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsPrimitive">
            <summary>
            Gets a value indicating whether this field is a primitive (<see cref="T:System.Int32"/>, <see cref="T:System.Single"/>, etc).
            </summary>
            <returns>True if this field is a primitive (<see cref="T:System.Int32"/>, <see cref="T:System.Single"/>, etc), false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsValueType">
            <summary>
            Gets a value indicating whether this field is a value type.
            </summary>
            <returns>True if this field is a value type, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsObjectReference">
            <summary>
            Gets a value indicating whether this field is an object reference.
            </summary>
            <returns>True if this field is an object reference, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Size">
            <summary>
            Gets the size of this field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsPublic">
            <summary>
            Gets a value indicating whether this field is public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsPrivate">
            <summary>
            Gets a value indicating whether this field is private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsInternal">
            <summary>
            Gets a value indicating whether this field is internal.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.IsProtected">
            <summary>
            Gets a value indicating whether this field is protected.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrField.Offset">
            <summary>
            For instance fields, this is the offset of the field within the object.
            For static fields this is the offset within the block of memory allocated for the module's static fields.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrField.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrFinalizerRoot">
            <summary>
            Represents a root that comes from the finalizer queue.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrGenericParameter">
            <summary>
            Returns information about generic parameters.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrGenericParameter.MetadataToken">
            <summary>
            The metadata token of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrGenericParameter.Index">
            <summary>
            The index of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrGenericParameter.Attributes">
            <summary>
            The attributes of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrGenericParameter.Name">
            <summary>
            The name of the parameter.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrGenericParameter.#ctor(System.Int32,System.Int32,System.Reflection.GenericParameterAttributes,System.String)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHandle">
            <summary>
            Represents a CLR handle in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Address">
            <summary>
            Gets the address of the handle itself.  That is, *ulong == Object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Object">
            <summary>
            Gets the Object the handle roots.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.HandleKind">
            <summary>
            Gets the type of handle.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.ReferenceCount">
            <summary>
            If this handle is a RefCount handle, this returns the reference count.
            RefCount handles with a RefCount > 0 are strong.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.Dependent">
            <summary>
            Gets the dependent handle target if this is a dependent handle.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.AppDomain">
            <summary>
            Gets the AppDomain the handle resides in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.IsStrong">
            <summary>
            Gets a value indicating whether the handle is strong (roots the object).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHandle.IsPinned">
            <summary>
            Gets a value indicating whether the handle pins the object (doesn't allow the GC to
            relocate it).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHandle.ToString">
            <summary>
            ToString override.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHandleKind">
            <summary>
            Types of CLR handles.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.WeakShort">
            <summary>
            Weak, short lived handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.WeakLong">
            <summary>
            Weak, long lived handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.Strong">
            <summary>
            Strong handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.Pinned">
            <summary>
            Strong handle, prevents relocation of target object.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.RefCounted">
            <summary>
            RefCounted handle (strong when the reference count is greater than 0).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.Dependent">
            <summary>
            A weak handle which may keep its "secondary" object alive if the "target" object is also alive.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.AsyncPinned">
            <summary>
            A strong, pinned handle (keeps the target object from being relocated), used for async IO operations.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.SizedRef">
            <summary>
            Strong handle used internally for book keeping.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrHandleKind.WeakWinRT">
            <summary>
            Weak WinRT handle.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrHeap">
            <summary>
            A representation of the CLR heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.Runtime">
            <summary>
            Gets the runtime associated with this heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.CanWalkHeap">
            <summary>
            Returns true if the GC heap is in a consistent state for heap enumeration.  This will return false
            if the process was stopped in the middle of a GC, which can cause the GC heap to be unwalkable.
            Note, you may still attempt to walk the heap if this function returns false, but you will likely
            only be able to partially walk each segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.LogicalHeapCount">
            <summary>
            Returns the number of logical heaps in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.Segments">
            <summary>
            A heap is has a list of contiguous memory regions called segments.  This list is returned in order of
            of increasing object addresses.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.FreeType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> representing free space on the GC heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.StringType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> representing <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.ObjectType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> representing <see cref="T:System.Object"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.ExceptionType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> representing <see cref="T:System.Exception"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrHeap.IsServer">
            <summary>
            Gets a value indicating whether the GC heap is in Server mode.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetObject(System.UInt64)">
            <summary>
            Gets a <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject"/> for the given address on this heap.
            </summary>
            <remarks>
            The returned object will have a <see langword="null"/> <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Type"/> if objRef does not point to
            a valid managed object.
            </remarks>
            <param name="objRef"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetObjectType(System.UInt64)">
            <summary>
            Obtains the type of an object at the given address.  Returns <see langword="null"/> if objRef does not point to
            a valid managed object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateObjects">
            <summary>
            Enumerates all objects on the heap.
            </summary>
            <returns>An enumerator for all objects on the heap.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateRoots">
            <summary>
            Enumerates all roots in the process.  Equivalent to the combination of:
                ClrRuntime.EnumerateHandles().Where(handle => handle.IsStrong)
                ClrRuntime.EnumerateThreads().SelectMany(thread => thread.EnumerateStackRoots())
                ClrHeap.EnumerateFinalizerRoots()
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetSegmentByAddress(System.UInt64)">
            <summary>
            Returns the GC segment which contains the given address.  This only searches ClrSegment.ObjectRange.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateFinalizableObjects">
            <summary>
            Enumerates all finalizable objects on the heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateFinalizerRoots">
            <summary>
            Enumerates all finalizable objects on the heap.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateAllocationContexts">
            <summary>
            Enumerates all AllocationContexts for all segments.  Allocation contexts are locations on the GC
            heap which the GC uses to allocate new objects.  These regions of memory do not contain objects.
            AllocationContexts are the reason that you cannot simply enumerate the heap by adding each object's
            size to itself to get the next object on the segment, since if the address is an allocation context
            you will have to skip past it to find the next valid object.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetSyncBlock(System.UInt64)">
            <summary>
            Obtains the SyncBlock data for a given object, if the object has an associated SyncBlock.
            </summary>
            <param name="obj">The object to get SyncBlock data for.</param>
            <returns>The SyncBlock for the object, null if the object does not have one.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.ToString">
            <summary>
            Returns a string representation of this heap, including the size and number of segments.
            </summary>
            <returns>The string representation of this heap.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetComFlags(System.UInt64)">
            <summary>
            This is an implementation helper.  Use ClrObject.IsComCallWrapper and ClrObject.IsRuntimeCallWrapper instead.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.GetObjectSize(System.UInt64,Microsoft.Diagnostics.Runtime.ClrType)">
            <summary>
            This is an implementation helper.  Use ClrObject.Size instead.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateObjectReferences(System.UInt64,Microsoft.Diagnostics.Runtime.ClrType,System.Boolean,System.Boolean)">
            <summary>
            This is an implementation helper.  Use <see cref="M:Microsoft.Diagnostics.Runtime.ClrObject.EnumerateReferences(System.Boolean,System.Boolean)">ClrObject.EnumerateReferences</see> instead.
            Enumerates all objects that the given object references.  This method is meant for internal use to
            implement ClrObject.EnumerateReferences, which you should use instead of calling this directly.
            </summary>
            <param name="obj">The object in question.</param>
            <param name="type">The type of the object.</param>
            <param name="considerDependantHandles">Whether to consider dependant handle mappings.</param>
            <param name="carefully">
            Whether to bounds check along the way (useful in cases where
            the heap may be in an inconsistent state.)
            </param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrHeap.EnumerateReferencesWithFields(System.UInt64,Microsoft.Diagnostics.Runtime.ClrType,System.Boolean,System.Boolean)">
            <summary>
            This is an implementation helper.
            Enumerates all objects that the given object references.  This method is meant for internal use to
            implement ClrObject.EnumerateReferencesWithFields, which you should use instead of calling this directly.
            </summary>
            <param name="obj">The object in question.</param>
            <param name="type">The type of the object.</param>
            <param name="considerDependantHandles">Whether to consider dependant handle mappings.</param>
            <param name="carefully">
            Whether to bounds check along the way (useful in cases where
            the heap may be in an inconsistent state.)
            </param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInstanceField">
            <summary>
            Represents an instance field of a type.   Fundamentally it represents a name and a type
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.Read``1(System.UInt64,System.Boolean)">
            <summary>
            Reads the value of the field as an unmanaged struct or primitive type.
            </summary>
            <typeparam name="T">An unmanaged struct or primitive type.</typeparam>
            <param name="objRef">The object to read the instance field from.</param>
            <param name="interior">Whether or not the field is interior to a struct.</param>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.ReadObject(System.UInt64,System.Boolean)">
            <summary>
            Reads the value of an object field.
            </summary>
            <param name="objRef">The object to read the instance field from.</param>
            <param name="interior">Whether or not the field is interior to a struct.</param>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.ReadStruct(System.UInt64,System.Boolean)">
            <summary>
            Reads a ValueType struct from the instance field.
            </summary>
            <param name="objRef">The object to read the instance field from.</param>
            <param name="interior">Whether or not the field is interior to a struct.</param>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.ReadString(System.UInt64,System.Boolean)">
            <summary>
            Reads a string from the instance field.
            </summary>
            <param name="objRef">The object to read the instance field from.</param>
            <param name="interior">Whether or not the field is interior to a struct.</param>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetAddress(System.UInt64)">
            <summary>
            Returns the address of the value of this field.  Equivalent to GetFieldAddress(objRef, false).
            </summary>
            <param name="objRef">The object to get the field address for.</param>
            <returns>The value of the field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInstanceField.GetAddress(System.UInt64,System.Boolean)">
            <summary>
            Returns the address of the value of this field.  Equivalent to GetFieldAddress(objRef, false).
            </summary>
            <param name="objRef">The object to get the field address for.</param>
            <param name="interior">
            Whether the enclosing type of this field is a value class,
            and that value class is embedded in another object.
            </param>
            <returns>The value of the field.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInterface">
            <summary>
            An interface implementation in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInterface.Name">
            <summary>
            Gets the typename of the interface.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInterface.BaseInterface">
            <summary>
            Gets the interface that this interface inherits from.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.ToString">
            <summary>
            Display string for this interface.
            </summary>
            <returns>Display string for this interface.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.Equals(System.Object)">
            <summary>
            Equals override.
            </summary>
            <param name="obj">Object to compare to.</param>
            <returns>True if this interface equals another.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInterface.GetHashCode">
            <summary>
            GetHashCode override.
            </summary>
            <returns>A hashcode for this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrMethod">
            <summary>
            Represents a method on a class.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.MethodDesc">
            <summary>
            Gets the first MethodDesc in EnumerateMethodDescs().  For single
            AppDomain programs this is the only MethodDesc.  MethodDescs
            are unique to an Method/AppDomain pair, so when there are multiple domains
            there will be multiple MethodDescs for a method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Name">
            <summary>
            Gets the name of the method.  For example, "void System.Foo.Bar(object o, int i)" would return "Bar".
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Signature">
            <summary>
            Gets the full signature of the function.  For example, "void System.Foo.Bar(object o, int i)"
            would return "System.Foo.Bar(System.Object, System.Int32)"
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.NativeCode">
            <summary>
            Gets the instruction pointer in the target process for the start of the method's assembly.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrMethod.GetILOffset(System.UInt64)">
            <summary>
            Gets the ILOffset of the given address within this method.
            </summary>
            <param name="addr">The absolute address of the code (not a relative offset).</param>
            <returns>The IL offset of the given address.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IL">
            <summary>
            Gets the location in memory of the IL for this method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.HotColdInfo">
            <summary>
            Gets the regions of memory that
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.CompilationType">
            <summary>
            Gets the way this method was compiled.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.ILOffsetMap">
            <summary>
            Gets the IL to native offset mapping.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.MetadataToken">
            <summary>
            Gets the metadata token of the current method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.Type">
            <summary>
            Gets the enclosing type of this method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPublic">
            <summary>
            Gets a value indicating whether this method is public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPrivate">
            <summary>
            Gets a value indicating whether this method is private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsInternal">
            <summary>
            Gets a value indicating whether this method is internal.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsProtected">
            <summary>
            Gets a value indicating whether this method is protected.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsStatic">
            <summary>
            Gets a value indicating whether this method is static.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsFinal">
            <summary>
            Gets a value indicating whether this method is final.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsPInvoke">
            <summary>
            Gets a value indicating whether this method is a P/Invoke.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsSpecialName">
            <summary>
            Gets a value indicating whether this method is a special method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsRTSpecialName">
            <summary>
            Gets a value indicating whether this method is a runtime special method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsVirtual">
            <summary>
            Gets a value indicating whether this method is virtual.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsAbstract">
            <summary>
            Gets a value indicating whether this method is abstract.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsConstructor">
            <summary>
            Gets a value indicating whether this method is an instance constructor.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrMethod.IsClassConstructor">
            <summary>
            Gets a value indicating whether this method is a static constructor.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrModule">
            <summary>
            Represents a managed module in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Address">
            <summary>
            Gets the address of the clr!Module object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AppDomain">
            <summary>
            Gets the AppDomain parent of this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AssemblyName">
            <summary>
            Gets the name of the assembly that this module is defined in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.AssemblyAddress">
            <summary>
            Gets an identifier to uniquely represent this assembly.  This value is not used by any other
            function in ClrMD, but can be used to group modules by their assembly.  (Do not use AssemblyName
            for this, as reflection and other special assemblies can share the same name, but actually be
            different.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Name">
            <summary>
            Gets the name of the module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsDynamic">
            <summary>
            Gets a value indicating whether this module was created through <c>System.Reflection.Emit</c> (and thus has no associated
            file).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.IsPEFile">
            <summary>
            Gets a value indicating whether this module is an actual PEFile on disk.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.ImageBase">
            <summary>
            Gets the base of the image loaded into memory.  This may be 0 if there is not a physical
            file backing it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Layout">
            <summary>
            Returns the in memory layout for PEImages.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Size">
            <summary>
            Gets the size of the image in memory.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataAddress">
            <summary>
            Gets the location of metadata for this module in the process's memory.  This is useful if you
            need to manually create IMetaData* objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataLength">
            <summary>
            Gets the length of the metadata for this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.MetadataImport">
            <summary>
            Gets the <c>IMetaDataImport</c> interface for this module.  Note that this API does not provide a
            wrapper for <c>IMetaDataImport</c>.  You will need to wrap the API yourself if you need to use this.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.DebuggingMode">
            <summary>
            Gets the debugging attributes for this module.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.EnumerateTypeDefToMethodTableMap">
            <summary>
            Enumerates the constructed methodtables in this module which correspond to typedef tokens defined by this module.
            </summary>
            <returns>An enumeration of (ulong methodTable, uint typeDef).</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.ResolveToken(System.Int32)">
            <summary>
            Resolves the given metadata token for this module.
            </summary>
            <param name="typeDefOrRefToken">A typedef or typeref token.</param>
            <returns>The ClrType of the resolved token, <see langword="null"/> if not found or if a type for the token hasn't been constructed by the runtime.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.GetTypeByName(System.String)">
            <summary>
            Attempts to obtain a ClrType based on the name of the type.  Note this is a "best effort" due to
            the way that the DAC handles types.  This function will fail for Generics, and types which have
            never been constructed in the target process.  Please be sure to null-check the return value of
            this function.
            </summary>
            <param name="name">The name of the type.  (This would be the EXACT value returned by ClrType.Name.)</param>
            <returns>The requested ClrType, or <see langword="null"/> if the type doesn't exist or if the runtime hasn't constructed it.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrModule.ToString">
            <summary>
            Returns a name for the assembly.
            </summary>
            <returns>A name for the assembly.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrModule.Pdb">
            <summary>
            Gets the PDB information for this module.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrObject">
            <summary>
            Represents an object in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.#ctor(System.UInt64,Microsoft.Diagnostics.Runtime.ClrType)">
            <summary>
            Constructor.
            </summary>
            <param name="address">The address of the object.</param>
            <param name="type">The concrete type of the object.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.EnumerateReferences(System.Boolean,System.Boolean)">
            <summary>
            Enumerates all objects that this object references.
            </summary>
            <param name="carefully">Only returns pointers which lie on the managed heap.  In very rare cases it's possible to
            create a crash dump where the GC was in the middle of updating data structures, or to create a crash dump of a process
            with heap corruption.  In those cases, setting carefully=true would ensure we would not enumerate those bad references.
            Note that setting carefully=true will cause a small performance penalty.</param>
            <param name="considerDependantHandles">Setting this to true will have ClrMD check for dependent handle references.
            Checking dependent handles does come at a performance penalty but will give you the true reference chain as the
            GC sees it.</param>
            <returns>An enumeration of object references.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.EnumerateReferencesWithFields(System.Boolean,System.Boolean)">
            <summary>
            Enumerates all objects that this object references.  This method also enumerates the field (or handle) that this
            reference comes from.
            </summary>
            <param name="carefully">Only returns pointers which lie on the managed heap.  In very rare cases it's possible to
            create a crash dump where the GC was in the middle of updating data structures, or to create a crash dump of a process
            with heap corruption.  In those cases, setting carefully=true would ensure we would not enumerate those bad references.
            Note that setting carefully=true will cause a small performance penalty.</param>
            <param name="considerDependantHandles">Setting this to true will have ClrMD check for dependent handle references.
            Checking dependent handles does come at a performance penalty but will give you the true reference chain as the
            GC sees it.</param>
            <returns>An enumeration of object references.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsBoxedValue">
            <summary>
            Returns true if this object is a boxed struct or primitive type that 
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.ReadBoxedValue``1">
            <summary>
            Reads a boxed primitive value.
            </summary>
            <typeparam name="T">An unmanaged struct or primitive type to read out of the object.</typeparam>
            <returns>The value read.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.Address">
            <summary>
            Gets the address of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.Type">
            <summary>
            Gets the type of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsFree">
            <summary>
            Returns whether this is free space on the GC heap and not a real object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsValid">
            <summary>
            Returns whether this is a valid object.  This will return null
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsNull">
            <summary>
            Returns if the object value is <see langword="null"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.Size">
            <summary>
            Gets the size of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.SyncBlock">
            <summary>
            Obtains the SyncBlock for this object.  Returns null if there is no SyncBlock associated with this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsComClassFactory">
            <summary>
            Returns true if this object is a COM class factory.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.HasComCallableWrapper">
            <summary>
            Returns true if this object is a ComCallableWrapper.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.HasRuntimeCallableWrapper">
            <summary>
            Returns true if this object is a RuntimeCallableWrapper.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.GetComCallableWrapper">
            <summary>
            Returns the ComCallableWrapper for the given object.
            </summary>
            <returns>The ComCallableWrapper associated with the object, <see langword="null"/> if obj is not a CCW.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.GetRuntimeCallableWrapper">
            <summary>
            Returns the RuntimeCallableWrapper for the given object.
            </summary>
            <returns>The RuntimeCallableWrapper associated with the object, <see langword="null"/> if obj is not a RCW.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.ContainsPointers">
            <summary>
            Gets a value indicating whether this object possibly contains GC pointers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrObject.IsArray">
            <summary>
            Gets a value indicating whether this object is an array.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.AsArray">
            <summary>
            returns the object as an array if the object has array type.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.op_Explicit(Microsoft.Diagnostics.Runtime.ClrObject)~System.String">
            <summary>
            Converts a ClrObject into its string value.
            </summary>
            <param name="obj">A string object.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.op_Implicit(Microsoft.Diagnostics.Runtime.ClrObject)~System.UInt64">
            <summary>
            Returns <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address"/> sweetening obj to pointer move.
            <Para>Example: ulong address = clrObject</Para>
            </summary>
            <param name="clrObject">An object to get address of.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.ReadObjectField(System.String)">
            <summary>
            Gets the given object reference field from this ClrObject.
            </summary>
            <param name="fieldName">The name of the field to retrieve.</param>
            <returns>A ClrObject of the given field.</returns>
            <exception cref="T:System.ArgumentException">The given field does not exist in the object.</exception>
            <exception cref="T:System.InvalidOperationException"><see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.IsNull"/> is <see langword="true"/>.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.ReadValueTypeField(System.String)">
            <summary>
            </summary>
            <param name="fieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.ReadField``1(System.String)">
            <summary>
            Gets the value of a primitive field.  This will throw an InvalidCastException if the type parameter
            does not match the field's type.
            </summary>
            <typeparam name="T">The type of the field itself.</typeparam>
            <param name="fieldName">The name of the field.</param>
            <returns>The value of this field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.ReadStringField(System.String,System.Int32)">
            <summary>
            Gets a string field from the object.  Note that the type must match exactly, as this method
            will not do type coercion.
            </summary>
            <param name="fieldName">The name of the field to get the value for.</param>
            <param name="maxLength">The maximum length of the string returned.  Warning: If the DataTarget
            being inspected has corrupted or an inconsistent heap state, the length of a string may be
            incorrect, leading to OutOfMemory and other failures.</param>
            <returns>The value of the given field.</returns>
            <exception cref="T:System.ArgumentException">No field matches the given name.</exception>
            <exception cref="T:System.InvalidOperationException">
            The target object is <see langword="null"/> (that is, <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.IsNull"/> is <see langword="true"/>).
            -or-
            The field is not of the correct type.
            </exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.Equals(Microsoft.Diagnostics.Runtime.ClrObject)">
            <summary>
            Determines if this instance and another specific <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> have the same value.
            <para>Instances are considered equal when they have same <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address" />.</para>
            </summary>
            <param name="other">The <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> to compare to this instance.</param>
            <returns><see langword="true"/> if the <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address" /> of the parameter is same as <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address" /> in this instance; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.Equals(System.Object)">
            <summary>
            Determines whether this instance and a specified object, which must also be a <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" />, have the same value.
            </summary>
            <param name="obj">The <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> to compare to this instance.</param>
            <returns>
            <see langword="true"/> if <paramref name="obj" /> is <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" />, and its <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address" /> is same as <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address" /> in this instance; <see langword="false"/>
            otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.GetHashCode">
            <summary>
            Returns the hash code for this <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> based on its <see cref="P:Microsoft.Diagnostics.Runtime.ClrObject.Address" />.
            </summary>
            <returns>An <see cref="T:System.Int32" /> hash code for this instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.op_Equality(Microsoft.Diagnostics.Runtime.ClrObject,Microsoft.Diagnostics.Runtime.ClrObject)">
            <summary>
            Determines whether two specified <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> have the same value.
            </summary>
            <param name="left">First <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> to compare.</param>
            <param name="right">Second <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> to compare.</param>
            <returns><see langword="true"/> if <paramref name="left" /> <see cref="M:Microsoft.Diagnostics.Runtime.ClrObject.Equals(Microsoft.Diagnostics.Runtime.ClrObject)" /> <paramref name="right" />; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.op_Inequality(Microsoft.Diagnostics.Runtime.ClrObject,Microsoft.Diagnostics.Runtime.ClrObject)">
            <summary>
            Determines whether two specified <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> have different values.
            </summary>
            <param name="left">First <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> to compare.</param>
            <param name="right">Second <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject" /> to compare.</param>
            <returns><see langword="true"/> if the value of <paramref name="left" /> is different from the value of <paramref name="right" />; <see langword="false"/> otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrObject.ToString">
            <summary>
            ToString override.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.Object">
            <summary>
            The object that <see cref="P:Microsoft.Diagnostics.Runtime.ClrReference.Field"/> contained.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.Offset">
            <summary>
            The offset into the containing object this address is found at.  Only valid if <see cref="P:Microsoft.Diagnostics.Runtime.ClrReference.IsField"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.InnerField">
            <summary>
            Resolves the inner field reference for value types.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.Field">
            <summary>
            The field this object was contained in.  This property may be null if this reference came from
            a DependentHandle or if the reference came from an array entry.
            Only valid to call if <see cref="P:Microsoft.Diagnostics.Runtime.ClrReference.IsField"/> is true.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.IsDependentHandle">
            <summary>
            Returns true if this reference came from a dependent handle.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.IsField">
            <summary>
            Returns true if this reference came from a field in another object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrReference.IsArrayElement">
            <summary>
            Returns true if this reference came from an entry in an array.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrReference.CreateFromDependentHandle(Microsoft.Diagnostics.Runtime.ClrObject)">
            <summary>
            Create a field reference from a dependent handle value.  We do not keep track of the dependent handle it came from
            so we don't accept the value here.
            </summary>
            <param name="reference">The object referenced.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrReference.CreateFromFieldOrArray(Microsoft.Diagnostics.Runtime.ClrObject,Microsoft.Diagnostics.Runtime.ClrType,System.Int32)">
            <summary>
            Creates a ClrFieldReference from an actual field.
            </summary>
            <param name="reference">The object referenced.</param>
            <param name="containingType">The type of the object which points to <paramref name="reference"/>.</param>
            <param name="offset">The offset within the source object where <paramref name="reference"/> was located.  This offset
            should start from where the object's data starts (IE this offset should NOT contain the MethodTable in the offset
            calculation.</param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRootKind">
            <summary>
            The type of GCRoot that a ClrRoot represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.None">
            <summary>
            This is not a gc root.  This will not be enumerated out of ClrHeap.EnumerateRoots, but
            could be seen when using ClrRuntime.EnumerateHandles.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.FinalizerQueue">
            <summary>
            The root comes from the finalizer queue.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.StrongHandle">
            <summary>
            The root is a strong handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.PinnedHandle">
            <summary>
            The root is a strong pinned handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.Stack">
            <summary>
            The root is on the stack of a thread.  This is usually a is a local variable
            (or compiler generated temporary variable).
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.RefCountedHandle">
            <summary>
            The root is a ref counted handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.AsyncPinnedHandle">
            <summary>
            The root is an async IO (strong) pinned handle.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrRootKind.SizedRefHandle">
            <summary>
            The root is a SizedRef handle.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrRuntime">
            <summary>
            Represents a single runtime in a target process or crash dump.  This serves as the primary
            entry point for getting diagnostic information.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.DacLibrary">
            <summary>
            Used for internal purposes.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.ClrInfo">
            <summary>
            Gets the <see cref="P:Microsoft.Diagnostics.Runtime.ClrRuntime.ClrInfo"/> of the current runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.DataTarget">
            <summary>
            Gets the <see cref="P:Microsoft.Diagnostics.Runtime.ClrRuntime.DataTarget"/> associated with this runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.IsThreadSafe">
            <summary>
            Returns whether you are allowed to call into the transitive closure of ClrMD objects created from
            this runtime on multiple threads.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.AppDomains">
            <summary>
            Gets the list of appdomains in the process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.SystemDomain">
            <summary>
            Gets the System AppDomain for Desktop CLR (<see langword="null"/> on .NET Core).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.SharedDomain">
            <summary>
            Gets the Shared AppDomain for Desktop CLR (<see langword="null"/> on .NET Core).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.Threads">
            <summary>
            Gets all managed threads in the process.  Only threads which have previously run managed
            code will be enumerated.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetMethodByHandle(System.UInt64)">
            <summary>
            Returns a ClrMethod by its internal runtime handle (on desktop CLR this is a MethodDesc).
            </summary>
            <param name="methodHandle">The method handle (MethodDesc) to look up.</param>
            <returns>The ClrMethod for the given method handle, or <see langword="null"/> if no method was found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetTypeByMethodTable(System.UInt64)">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> corresponding to the given MethodTable.
            </summary>
            <param name="methodTable">The ClrType.MethodTable for the requested type.</param>
            <returns>A ClrType object, or <see langword="null"/> if no such type exists.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateHandles">
            <summary>
            Enumerates a list of GC handles currently in the process.  Note that this list may be incomplete
            depending on the state of the process when we attempt to walk the handle table.
            </summary>
            <returns>The list of GC handles in the process, NULL on catastrophic error.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrRuntime.Heap">
            <summary>
            Gets the GC heap of the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetMethodByInstructionPointer(System.UInt64)">
            <summary>
            Attempts to get a ClrMethod for the given instruction pointer.  This will return NULL if the
            given instruction pointer is not within any managed method.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.EnumerateModules">
            <summary>
            Enumerate all managed modules in the runtime.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.FlushCachedData">
            <summary>
            Flushes the DAC cache.  This function MUST be called any time you expect to call the same function
            but expect different results.  For example, after walking the heap, you need to call Flush before
            attempting to walk the heap again.  After calling this function, you must discard ALL ClrMD objects
            you have cached other than DataTarget and ClrRuntime and re-request the objects and data you need.
            (e.g. if you want to use the ClrHeap object after calling flush, you must call ClrRuntime.GetHeap
            again after Flush to get a new instance.)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.GetJitHelperFunctionName(System.UInt64)">
            <summary>
            Gets the name of a JIT helper function.
            </summary>
            <param name="address">Address of a possible JIT helper function.</param>
            <returns>The name of the JIT helper function or <see langword="null"/> if <paramref name="address"/> isn't a JIT helper function.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.Dispose">
            <summary>
            Cleans up all resources and releases them.  You may not use this ClrRuntime or any object it transitively
            created after calling this method.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrRuntime.Dispose(System.Boolean)">
            <summary>
            Called when disposing ClrRuntime.
            </summary>
            <param name="disposing">Whether Dispose() was called or not.</param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrSegment">
            <summary>
            A ClrSegment represents a contiguous region of memory that is devoted to the GC heap.
            Segments.  It has a start and end and knows what heap it belongs to.   Segments can
            optional have regions for Gen 0, 1 and 2, and Large properties.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Heap">
            <summary>
            Gets the GC heap associated with this segment.  There's only one GCHeap per process, so this is
            only a convenience method to keep from having to pass the heap along with a segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.ObjectRange">
            <summary>
            The memory range of the segment on which objects are allocated.  All objects in this segment fall within this range.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Start">
            <summary>
            Gets the start address of the segment.  Equivalent to <see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.ObjectRange"/>.<see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.Start"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.End">
            <summary>
            Gets the end address of the segment.  Equivalent to <see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.ObjectRange"/>.<see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.Length"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Length">
            <summary>
            Equivalent to <see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.ObjectRange"/>.<see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.Length"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.LogicalHeap">
            <summary>
            Gets the processor that this heap is affinitized with.  In a workstation GC, there is no processor
            affinity (and the return value of this property is undefined).  In a server GC each segment
            has a logical processor in the PC associated with it.  This property returns that logical
            processor number (starting at 0).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.ReservedMemory">
            <summary>
            Gets the range of memory reserved (but not committed) for this segment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.CommittedMemory">
            <summary>
            Gets the range of memory committed for the segment (this may be larger than MemoryRange).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.FirstObjectAddress">
            <summary>
            Gets the first object on this segment or 0 if this segment contains no objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.IsLargeObjectSegment">
            <summary>
            Returns true if this is a segment for the Large Object Heap.  False otherwise.
            Large objects (greater than 85,000 bytes in size), are stored in their own segments and
            only collected on full (gen 2) collections.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.IsPinnedObjectSegment">
            <summary>
            Returns true if this is a segment for the Pinned Object Heap.  False otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.IsEphemeralSegment">
            <summary>
            Returns true if this segment is the ephemeral segment (meaning it contains gen0 and gen1
            objects).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Generation0">
            <summary>
            The memory range for Generation 0 on this segment.  This will be empty if <see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.IsEphemeralSegment"/> is false.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Generation1">
            <summary>
            The memory range for Generation 1 on this segment.  This will be empty if <see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.IsEphemeralSegment"/> is false.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrSegment.Generation2">
            <summary>
            The memory range for Generation 2 on this segment.  This will be equivalent to ObjectRange if <see cref="P:Microsoft.Diagnostics.Runtime.ClrSegment.IsEphemeralSegment"/> is false.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.EnumerateObjects">
            <summary>
            Enumerates all objects on the segment.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.GetNextObjectAddress(System.UInt64)">
            <summary>
            Returns the object after the given object.
            </summary>
            <param name="obj">A valid object address that resides on this segment.</param>
            <returns>The next object on this segment, or 0 if <paramref name="obj"/> is the last object on the segment.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.GetPreviousObjectAddress(System.UInt64)">
            <summary>
            Returns the object before the given object.  Note that this function may take a while because in the worst case
            scenario we have to linearly walk all the way from the beginning of the segment to the object.
            </summary>
            <param name="obj">An address that resides on this segment.  This does not need to point directly to a good object.</param>
            <returns>The previous object on this segment, or 0 if <paramref name="obj"/> is the first object on the segment.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.GetGeneration(System.UInt64)">
            <summary>
            Returns the generation of an object in this segment.
            </summary>
            <param name="obj">An object in this segment.</param>
            <returns>
            The generation of the given object if that object lies in this segment.  The return
            value is undefined if the object does not lie in this segment.
            </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrSegment.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStackFrame">
            <summary>
            A frame in a managed stack trace.  Note you can call ToString on an instance of this object to get the
            function name (or clr!Frame name) similar to SOS's !clrstack output.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Thread">
            <summary>
            The thread parent of this frame.  Note that this may be null when inspecting the stack of ClrExceptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Context">
            <summary>
            Gets this stack frame context.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.InstructionPointer">
            <summary>
            Gets the instruction pointer of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.StackPointer">
            <summary>
            Gets the stack pointer of this frame.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Kind">
            <summary>
            Gets the type of frame (managed or internal).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Method">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrMethod"/> which corresponds to the current stack frame.  This may be <see langword="null"/> if the
            current frame is actually a CLR "Internal Frame" representing a marker on the stack, and that
            stack marker does not have a managed method associated with it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.FrameName">
            <summary>
            Gets the helper method frame name if <see cref="P:Microsoft.Diagnostics.Runtime.ClrStackFrame.Kind"/> is <see cref="F:Microsoft.Diagnostics.Runtime.ClrStackFrameKind.Runtime"/>, <see langword="null"/> otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStackFrameKind">
            <summary>
            The type of frame the ClrStackFrame represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameKind.Unknown">
            <summary>
            Indicates this stack frame is unknown
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameKind.ManagedMethod">
            <summary>
            Indicates this stack frame is a standard managed method.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrStackFrameKind.Runtime">
            <summary>
            Indicates this stack frame is a special stack marker that the CLR leaves on the stack.
            Note that the <see cref="T:Microsoft.Diagnostics.Runtime.ClrStackFrame"/> may still have a <see cref="T:Microsoft.Diagnostics.Runtime.ClrMethod"/> associated with the marker.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStackInteriorRoot.ToString">
            <summary>
            ToString override.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrStaticField">
            <summary>
            Represents a static field in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.IsInitialized(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Returns whether this static field has been initialized in a particular AppDomain
            or not.  If a static variable has not been initialized, then its class constructor
            may have not been run yet.  Calling any of the Read* methods on an uninitialized static
            will result in returning either NULL or a value of 0.
            </summary>
            <param name="appDomain">The AppDomain to see if the variable has been initialized.</param>
            <returns>
            True if the field has been initialized (even if initialized to NULL or a default
            value), false if the runtime has not initialized this variable.
            </returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.GetAddress(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Gets the address of the static field's value in memory.
            </summary>
            <returns>The address of the field's value.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.Read``1(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Reads the value of the field as an unmanaged struct or primitive type.
            </summary>
            <typeparam name="T">An unmanaged struct or primitive type.</typeparam>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.ReadObject(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Reads the value of an object field.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.ReadStruct(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Reads a ValueType struct from the instance field.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrStaticField.ReadString(Microsoft.Diagnostics.Runtime.ClrAppDomain)">
            <summary>
            Reads a string from the instance field.
            </summary>
            <returns>The value read.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrThread">
            <summary>
            Represents a managed thread in the target process.  Note this does not wrap purely native threads
            in the target process (that is, threads which have never run managed code before).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.Runtime">
            <summary>
            Gets the runtime associated with this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.GCMode">
            <summary>
            Gets the suspension state of the thread according to the runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsFinalizer">
            <summary>
            Gets a value indicating whether this is the finalizer thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.Address">
            <summary>
            Gets the address of the underlying datastructure which makes up the Thread object.  This
            serves as a unique identifier.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAlive">
            <summary>
            Returns true if the thread is alive in the process, false if this thread was recently terminated.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.OSThreadId">
            <summary>
            Gets the OS thread id for the thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.ManagedThreadId">
            <summary>
            Gets the managed thread ID (this is equivalent to <see cref="P:System.Threading.Thread.ManagedThreadId"/>
            in the target process).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.CurrentAppDomain">
            <summary>
            Gets the AppDomain the thread is running in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.LockCount">
            <summary>
            Gets the number of managed locks (Monitors) the thread has currently entered but not left.
            This will be highly inconsistent unless the process is stopped.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackBase">
            <summary>
            Gets the base of the stack for this thread, or 0 if the value could not be obtained.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.StackLimit">
            <summary>
            Gets the limit of the stack for this thread, or 0 if the value could not be obtained.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThread.EnumerateStackRoots">
            <summary>
            Enumerates the GC references (objects) on the stack.  The returned IClrRoot may either be an
            <see cref="T:Microsoft.Diagnostics.Runtime.ClrStackRoot"/> or a <see cref="T:Microsoft.Diagnostics.Runtime.ClrStackInteriorRoot"/>.
            </summary>
            <returns>An enumeration of GC references on the stack as the GC sees them.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrThread.EnumerateStackTrace(System.Boolean)">
            <summary>
            Enumerates a stack trace for a given thread.  Note this method may loop infinitely in the case of
            stack corruption or other stack unwind issues which can happen in practice.  When enumerating frames
            out of this method you should be careful to either set a maximum loop count, or to ensure the stack
            unwind is making progress by ensuring that ClrStackFrame.StackPointer is making progress (though it
            is expected that sometimes two frames may return the same StackPointer in some corner cases).
            </summary>
            <returns>An enumeration of stack frames.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.CurrentException">
            <summary>
            Gets the exception currently on the thread.  Note that this field may be <see langword="null"/>.  Also note
            that this is basically the "last thrown exception", and may be stale...meaning the thread could
            be done processing the exception but a crash dump was taken before the current exception was
            cleared off the field.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAbortRequested">
            <summary>
            Gets a value indicating whether an abort was requested for this thread (such as <see cref="M:System.Threading.Thread.Abort"/>, or <see cref="M:System.AppDomain.Unload(System.AppDomain)"/>).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsAborted">
            <summary>
            Gets a value indicating whether this thread was aborted.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsGCSuspendPending">
            <summary>
            Gets a value indicating whether the GC is attempting to suspend this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsUserSuspended">
            <summary>
            Gets a value indicating whether the user has suspended the thread (using <see cref="M:System.Threading.Thread.Suspend"/>).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsDebugSuspended">
            <summary>
            Gets a value indicating whether the debugger has suspended the thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsBackground">
            <summary>
            Gets a value indicating whether this thread is a background thread.  (That is, if the thread does not keep the
            managed execution environment alive and running.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsUnstarted">
            <summary>
            Gets a value indicating whether this thread was created, but not started.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsCoInitialized">
            <summary>
            Gets a value indicating whether the CLR called <c>CoInitialize</c> for this thread.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsSTA">
            <summary>
            Gets a value indicating whether this thread is in a COM single threaded apartment.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrThread.IsMTA">
            <summary>
            Gets a value indicating whether the thread is a COM multithreaded apartment.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrType">
            <summary>
            A representation of a type in the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.GCDesc">
            <summary>
            Gets the <see cref="P:Microsoft.Diagnostics.Runtime.ClrType.GCDesc"/> associated with this type.  Only valid if <see cref="P:Microsoft.Diagnostics.Runtime.ClrType.ContainsPointers"/> is <see langword="true"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.MethodTable">
            <summary>
            Gets the MethodTable of this type (this is the TypeHandle if this is a type without a MethodTable).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.MetadataToken">
            <summary>
            Gets the metadata token of this type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Name">
            <summary>
            Gets the name of this type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ContainsPointers">
            <summary>
            Gets a value indicating whether the type <b>can</b> contain references to other objects.  This is used in optimizations
            and 'true' can always be returned safely.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsCollectible">
            <summary>
            Gets a value indicating whether this is a collectible type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.LoaderAllocatorHandle">
            <summary>
            Gets the handle to the <c>LoaderAllocator</c> object for collectible types.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.AssemblyLoadContextAddress">
            <summary>
            Gets the address of the <c>AssemblyLoadContext</c> object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Heap">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrHeap"/> this type belongs to.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Module">
            <summary>
            Gets the module this type is defined in.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ElementType">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrElementType"/> of this Type.  Can return <see cref="F:Microsoft.Diagnostics.Runtime.ClrElementType.Unknown"/> on error.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPrimitive">
            <summary>
            Gets a value indicating whether this type is a primitive (<see cref="T:System.Int32"/>, <see cref="T:System.Single"/>, etc).
            </summary>
            <returns>True if this type is a primitive (<see cref="T:System.Int32"/>, <see cref="T:System.Single"/>, etc), false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsValueType">
            <summary>
            Gets a value indicating whether this type is a value type.
            </summary>
            <returns>True if this type is a value type, false otherwise.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsObjectReference">
            <summary>
            Gets a value indicating whether this type is an object reference.
            </summary>
            <returns>True if this type is an object reference, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.EnumerateGenericParameters">
            <summary>
            Enumerates the generic parameters of this type.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.EnumerateInterfaces">
            <summary>
            Returns the list of interfaces this type implements.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.IsFinalizeSuppressed(System.UInt64)">
            <summary>
            Returns true if the finalization is suppressed for an object (the user program called
            <see cref="M:System.GC.SuppressFinalize(System.Object)"/>). The behavior of this function is undefined if the object itself
            is not finalizable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsFinalizable">
            <summary>
            Gets a value indicating whether objects of this type are finalizable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPublic">
            <summary>
            Gets a value indicating whether this type is marked Public.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPrivate">
            <summary>
            Gets a value indicating whether this type is marked Private.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsInternal">
            <summary>
            Gets a value indicating whether this type is accessible only by items in its own assembly.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsProtected">
            <summary>
            Gets a value indicating whether this nested type is accessible only by subtypes of its outer type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsAbstract">
            <summary>
            Gets a value indicating whether this class is abstract.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsSealed">
            <summary>
            Gets a value indicating whether this class is sealed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsInterface">
            <summary>
            Gets a value indicating whether this type is an interface.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Fields">
            <summary>
            Gets all possible fields in this type.   It does not return dynamically typed fields.
            Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.StaticFields">
            <summary>
            Gets a list of static fields on this type.  Returns an empty list if there are no fields.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.Methods">
            <summary>
            Gets the list of methods this type implements.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetFieldByName(System.String)">
            <summary>
            Returns the field given by <paramref name="name"/>, case sensitive. Returns <see langword="null" /> if no such field name exists (or on error).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetStaticFieldByName(System.String)">
            <summary>
            Returns the field given by <paramref name="name"/>, case sensitive. Returns <see langword="null" /> if no such field name exists (or on error).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.BaseType">
            <summary>
            If this type inherits from another type, this is that type.  Can return <see langword="null"/> if it does not inherit (or is unknown).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsPointer">
            <summary>
            Gets a value indicating whether the type is in fact a pointer. If so, the pointer operators
            may be used.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ComponentType">
            <summary>
            Gets the type of the element referenced by the pointer.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsArray">
            <summary>
            A type is an array if you can use the array operators below, Abstractly arrays are objects
            that whose children are not statically known by just knowing the type.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.GetArrayElementAddress(System.UInt64,System.Int32)">
            <summary>
            Returns the absolute address to the given array element.  You may then make a direct memory read out
            of the process to get the value if you want.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.ReadArrayElements``1(System.UInt64,System.Int32,System.Int32)">
            <summary>
            Returns multiple consecutive array element values.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.StaticSize">
            <summary>
            Gets the static size of objects of this type when they are created on the CLR heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ComponentSize">
            <summary>
            Gets the size of elements of this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsString">
            <summary>
            Gets a value indicating whether this type is <see cref="T:System.String"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsFree">
            <summary>
            Gets a value indicating whether this type represents free space on the heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsException">
            <summary>
            Gets a value indicating whether this type is an exception (that is, it derives from <see cref="T:System.Exception"/>).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsEnum">
            <summary>
            Gets a value indicating whether this type is an enum.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.AsEnum">
            <summary>
            Returns the <see cref="T:Microsoft.Diagnostics.Runtime.ClrEnum"/> representation of this type.
            </summary>
            <returns>The <see cref="T:Microsoft.Diagnostics.Runtime.ClrEnum"/> representation of this type.</returns>
            <exception cref="T:System.InvalidOperationException"><see cref="P:Microsoft.Diagnostics.Runtime.ClrType.IsEnum"/> is <see langword="false"/>.</exception>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.IsShared">
            <summary>
            Gets a value indicating whether this type is shared across multiple AppDomains.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrType.ToString">
            <summary>
            Returns a string representation of this object.
            </summary>
            <returns>A string representation of this object.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrType.ClrObjectHelpers">
            <summary>
            Used to provide functionality to ClrObject.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrValueType">
            <summary>
            Represents an instance of a type which inherits from <see cref="T:System.ValueType"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrValueType.Address">
            <summary>
            Gets the address of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrValueType.Type">
            <summary>
            Gets the type of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrValueType.IsValid">
            <summary>
            Returns whether this ClrValueType has a valid Type.  In most normal operations of ClrMD, we will have a
            non-null type.  However if we are missing metadata, or in some generic cases we might not be able to
            determine the type of this value type.  In those cases, Type? will be null and IsValid will return false.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrValueType.ReadObjectField(System.String)">
            <summary>
            Gets the given object reference field from this ClrObject.
            </summary>
            <param name="fieldName">The name of the field to retrieve.</param>
            <returns>A ClrObject of the given field.</returns>
            <exception cref="T:System.ArgumentException">
            The given field does not exist in the object.
            -or-
            The given field was not an object reference.
            </exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrValueType.ReadField``1(System.String)">
            <summary>
            Gets the value of a primitive field.  This will throw an InvalidCastException if the type parameter
            does not match the field's type.
            </summary>
            <typeparam name="T">The type of the field itself.</typeparam>
            <param name="fieldName">The name of the field.</param>
            <returns>The value of this field.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrValueType.ReadValueTypeField(System.String)">
            <summary>
            </summary>
            <param name="fieldName"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrValueType.ReadStringField(System.String,System.Int32)">
            <summary>
            Gets a string field from the object.  Note that the type must match exactly, as this method
            will not do type coercion.
            </summary>
            <param name="fieldName">The name of the field to get the value for.</param>
            <param name="maxLength">The maximum length of the string returned.  Warning: If the DataTarget
            being inspected has corrupted or an inconsistent heap state, the length of a string may be
            incorrect, leading to OutOfMemory and other failures.</param>
            <returns>The value of the given field.</returns>
            <exception cref="T:System.ArgumentException">No field matches the given name.</exception>
            <exception cref="T:System.InvalidOperationException">The field is not a string.</exception>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ComCallableWrapper">
            <summary>
            Helper for COM Callable Wrapper objects.  (CCWs are CLR objects exposed to native code as COM
            objects).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComCallableWrapper.IUnknown">
            <summary>
            Gets the pointer to the IUnknown representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComCallableWrapper.Object">
            <summary>
            Gets the pointer to the managed object representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComCallableWrapper.Handle">
            <summary>
            Gets the CLR handle associated with this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComCallableWrapper.RefCount">
            <summary>
            Gets the refcount of this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComCallableWrapper.Interfaces">
            <summary>
            Gets the interfaces that this CCW implements.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ComInterfaceData">
            <summary>
            The COM implementation details of a single CCW entry.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComInterfaceData.Type">
            <summary>
            Gets the CLR type this represents.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ComInterfaceData.InterfacePointer">
            <summary>
            Gets the interface pointer of Type.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCMode">
            <summary>
            Defines the state of the thread from the runtime's perspective.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCMode.Cooperative">
            <summary>
            In Cooperative mode the thread must cooperate before a GC may proceed.  This means when a GC
            starts, the runtime will attempt to suspend the thread at a safepoint but cannot immediately
            stop the thread until it synchronizes.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.GCMode.Preemptive">
            <summary>
            In Preemptive mode the runtime is free to suspend the thread at any time for a GC to occur.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCRootProgressUpdatedEventHandler">
            <summary>
            A delegate for reporting GCRoot progress.
            </summary>
            <param name="source">The GCRoot sending the event.</param>
            <param name="processed">The total number of objects processed.</param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCRoot">
            <summary>
            A helper class to find the GC rooting chain for a particular object.
            </summary>
        </member>
        <member name="E:Microsoft.Diagnostics.Runtime.GCRoot.ProgressUpdated">
            <summary>
            Since GCRoot can be long running, this event will provide periodic updates to how many objects the algorithm
            has processed.  Note that in the case where we search all objects and do not find a path, it's unlikely that
            the number of objects processed will ever reach the total number of objects on the heap.  That's because there
            will be garbage objects on the heap we can't reach.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.GCRoot.Heap">
            <summary>
            Gets the heap that's associated with this GCRoot instance.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.GCRoot.#ctor(Microsoft.Diagnostics.Runtime.ClrHeap)">
            <summary>
            Creates a GCRoot helper object for the given heap.
            </summary>
            <param name="heap">The heap the object in question is on.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.GCRoot.EnumerateGCRoots(System.UInt64,System.Threading.CancellationToken)">
            <summary>
            Enumerates GCRoots of a given object.  Similar to !gcroot.  Note this function only returns paths that are fully unique.
            </summary>
            <param name="target">The target object to search for GC rooting.</param>
            <param name="cancellationToken">A cancellation token to stop enumeration.</param>
            <returns>An enumeration of all GC roots found for target.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.GCRoot.EnumerateGCRoots(System.UInt64,System.Boolean,System.Int32,System.Collections.Generic.IEnumerable{Microsoft.Diagnostics.Runtime.IClrRoot},System.Threading.CancellationToken)">
            <summary>
            Enumerates GCRoots of a given object.  Similar to !gcroot.
            </summary>
            <param name="target">The target object to search for GC rooting.</param>
            <param name="returnOnlyFullyUniquePaths">Whether to only return fully unique paths.</param>
            <param name="maxDegreeOfParallelism">The number of threads this class is allowed to use to calculate the result.
            Setting this to 1 will cause the algorithm to run on the current thread.</param>
            <param name="roots">The roots to consider.  You can pass ClrMD.</param>
            <param name="cancellationToken">A cancellation token to stop enumeration.</param>
            <returns>An enumeration of all GC roots found for target.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.GCRoot.FindSinglePath(System.UInt64,System.UInt64,System.Threading.CancellationToken)">
            <summary>
            Returns the path from the start object to the end object (or <see langword="null"/> if no such path exists).
            </summary>
            <param name="source">The initial object to start the search from.</param>
            <param name="target">The object we are searching for.</param>
            <param name="cancellationToken">A cancellation token to stop searching.</param>
            <returns>A path from 'source' to 'target' if one exists, <see langword="null"/> if one does not.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.GCRoot.EnumerateAllPaths(System.UInt64,System.UInt64,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Returns the path from the start object to the end object (or <see langword="null"/> if no such path exists).
            </summary>
            <param name="source">The initial object to start the search from.</param>
            <param name="target">The object we are searching for.</param>
            <param name="returnOnlyFullyUniquePaths">Whether to only enumerate fully unique paths.</param>
            <param name="cancellationToken">A cancellation token to stop enumeration.</param>
            <returns>A path from 'source' to 'target' if one exists, <see langword="null"/> if one does not.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.GCRootPath">
            <summary>
            Represents a path of objects from a root to an object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.GCRootPath.Root">
            <summary>
            Gets the location that roots the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.GCRootPath.Path">
            <summary>
            Gets the path from Root to a given target object.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.HotColdRegions">
            <summary>
            Returns the addresses and sizes of the hot and cold regions of a method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HotColdRegions.HotStart">
            <summary>
            Gets the start address of the method's hot region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HotColdRegions.HotSize">
            <summary>
            Gets the size of the hot region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HotColdRegions.ColdStart">
            <summary>
            Gets the start address of the method's cold region.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.HotColdRegions.ColdSize">
            <summary>
            Gets the size of the cold region.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.IAddressableTypedEntity">
            <summary>
            Represents an addressable entity (class or struct) with associated type.
            <para>Allows locating field values by known names.</para>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IAddressableTypedEntity.Address">
            <summary>
            Gets the address of this entity.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IAddressableTypedEntity.Type">
            <summary>
            Gets the type associated with this entity.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IAddressableTypedEntity.ReadField``1(System.String)">
            <summary>
            Gets the value of a primitive field (i.e. <see cref="T:System.Int32"/>, <see cref="T:System.Boolean"/>) or an unmanaged struct.
            </summary>
            <typeparam name="T">The primitive type of the field.</typeparam>
            <param name="fieldName">The name of the field to read value from.</param>
            <returns>The value of the field.</returns>
            <exception cref="T:System.ArgumentException">Thrown when field was not found by name.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IAddressableTypedEntity.ReadStringField(System.String,System.Int32)">
            <summary>
            Gets the <see cref="T:System.String"/> value from the entity field.
            <para>Note that the type must match exactly, as this method
            will not do type coercion.</para>
            </summary>
            <param name="fieldName">The name of the field to get the value for.</param>
            <returns>The value of the given field.</returns>
            <exception cref="T:System.ArgumentException">Thrown when field was not found by name.</exception>
            <exception cref="T:System.InvalidOperationException">Thrown when found field has other type than <see cref="T:System.String"/>.</exception>
            <param name="maxLength">The maximum length of the string returned.  Warning: If the DataTarget
            being inspected has corrupted or an inconsistent heap state, the length of a string may be
            incorrect, leading to OutOfMemory and other failures.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IAddressableTypedEntity.ReadValueTypeField(System.String)">
            <summary>
            Gets the struct field value from the entity field.
            </summary>
            <param name="fieldName">The name of the field to get the value for.</param>
            <returns>The value of the given field.</returns>
            <exception cref="T:System.ArgumentException">Thrown when field was not found by name, or found field is not of struct type.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IAddressableTypedEntity.ReadObjectField(System.String)">
            <summary>
            Gets the value of reference field.
            </summary>
            <param name="fieldName">The name of the field to read value from.</param>
            <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.ClrObject"/> found field points on.</returns>
            <exception cref="T:System.ArgumentException">Thrown when field was not found by name, or found field is not of reference type.</exception>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.IBinaryLocator">
             <summary>
             ClrMD needs to be able to locate files that were used when the process the DataTarget
             represents was running.
            
             Implementers of this interface MUST be thread safe.
             </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IBinaryLocator.FindBinary(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.  May be called
            from multiple threads at the same time.
            </summary>
            <param name="fileName">The file name or path of the binary to locate.</param>
            <param name="buildTimeStamp">The build timestamp the binary is indexed under.</param>
            <param name="imageSize">The image size the binary is indexed under.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, <see langword="null"/> if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IBinaryLocator.FindBinaryAsync(System.String,System.Int32,System.Int32,System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.  May be called
            from multiple threads at the same time.
            </summary>
            <param name="fileName">The file name or path of the binary to locate.</param>
            <param name="buildTimeStamp">The build timestamp the binary is indexed under.</param>
            <param name="imageSize">The image size the binary is indexed under.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, <see langword="null"/> if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IBinaryLocator.FindBinary(System.String,System.Collections.Immutable.ImmutableArray{System.Byte},System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.  May be called
            from multiple threads at the same time.
            </summary>
            <param name="fileName">The file name or path of the binary to locate.</param>
            <param name="buildId">The build id that the binary is indexed under.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, <see langword="null"/> if it was not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IBinaryLocator.FindBinaryAsync(System.String,System.Collections.Immutable.ImmutableArray{System.Byte},System.Boolean)">
            <summary>
            Attempts to locate a binary via the symbol server.  This function will then copy the file
            locally to the symbol cache and return the location of the local file on disk.  May be called
            from multiple threads at the same time.
            </summary>
            <param name="fileName">The file name or path of the binary to locate.</param>
            <param name="buildId">The build id that the binary is indexed under.</param>
            <param name="checkProperties">Whether or not to validate the properties of the binary after download.</param>
            <returns>A full path on disk (local) of where the binary was copied to, <see langword="null"/> if it was not found.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IClrRoot.Address">
            <summary>
            Gets the address in memory of the root.  Typically dereferencing this address will
            give you the associated Object, but not always.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IClrRoot.Object">
            <summary>
            Gets the object the root points to.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IClrRoot.RootKind">
            <summary>
            Gets the kind of root this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IClrRoot.IsInterior">
            <summary>
            Gets a value indicating whether Address may point to the interior of an object (i.e. not the start of an object).
            If Address happens to point to the start of the object, IClrRoot.Object will be filled
            as normal, otherwise IClrRoot.Object.IsNull will be <see langword="true"/>.  In order to properly account
            for interior objects, you must read the value out of Address then find the object which
            contains it.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IClrRoot.IsPinned">
            <summary>
            Gets a value indicating whether the object is pinned in place by this root and will not be relocated by the GC.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ILInfo">
            <summary>
            Returns information about the IL for a method.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ILInfo.Address">
            <summary>
            Gets the address in memory of where the IL for a particular method is located.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ILInfo.Length">
            <summary>
            Gets the length (in bytes) of the IL method body.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ILInfo.Flags">
            <summary>
            Gets the flags associated with the IL code.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ILInfo.LocalVarSignatureToken">
            <summary>
            Gets the local variable signature token for this IL method.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ILToNativeMap">
            <summary>
            A method's mapping from IL to native offsets.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.ILOffset">
            <summary>
            The IL offset for this entry.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.StartAddress">
            <summary>
            The native start offset of this IL entry.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap.EndAddress">
            <summary>
            The native end offset of this IL entry.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ILToNativeMap.ToString">
            <summary>
            To string.
            </summary>
            <returns>A visual display of the map entry.</returns>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ILToNativeMap._reserved">
            <summary>
            Reserved.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.MemoryRange">
            <summary>
            Represents a range of memory in the target process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.CreateFromLength(System.UInt64,System.UInt64)">
            <summary>
            Creates a memory range from an address and its length.
            </summary>
            <param name="start">The start address.</param>
            <param name="length">The length of the range.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.#ctor(System.UInt64,System.UInt64)">
            <summary>
            Constructor.
            </summary>
            <param name="start">The start of the memory range.</param>
            <param name="end">The end of the memory range.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.MemoryRange.Start">
            <summary>
            The inclusive start address of the memory range.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.MemoryRange.End">
            <summary>
            The exclusive end address of the memory range.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.MemoryRange.Length">
            <summary>
            The length of the memory range in bytes.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.Contains(System.UInt64)">
            <summary>
            Returns whether the memory range contains the given address.
            </summary>
            <param name="address">The address to check.</param>
            <returns>True if the memory range contains the given address.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.Overlaps(Microsoft.Diagnostics.Runtime.MemoryRange)">
            <summary>
            Returns whether this memory range and <paramref name="other"/> contains any addresses which
            overlap.
            </summary>
            <param name="other">The other memory range to compare this to.</param>
            <returns>True if memory ranges overlap at all.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.Contains(Microsoft.Diagnostics.Runtime.MemoryRange)">
            <summary>
            Returns whether this memory range contains all of <paramref name="other"/>.
            </summary>
            <param name="other">The other memory range to compare this to.</param>
            <returns>True if this memory range completely encloses <paramref name="other"/>.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.ToString">
            <summary>
            Returns the range of memory in interval form, ie [start,end).  Since End is not inclusive, we use ')' to denote
            that the range does not include that address.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemoryRange.CompareTo(System.UInt64)">
            <summary>
            CompareTo implementation for a single address.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.MethodCompilationType">
            <summary>
            The way a method was JIT'ed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.None">
            <summary>
            Method is not yet JITed and no NGEN image exists.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.Jit">
            <summary>
            Method was JITed.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.MethodCompilationType.Ngen">
            <summary>
            Method was NGEN'ed (pre-JITed).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ModuleInfo">
            <summary>
            Provides information about loaded modules in a <see cref="P:Microsoft.Diagnostics.Runtime.ModuleInfo.DataTarget"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.DataTarget">
            <summary>
            The DataTarget which contains this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.ImageBase">
            <summary>
            Gets the base address of the object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.IndexFileSize">
            <summary>
            Gets the specific file size of the image used to index it on the symbol server.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.IndexTimeStamp">
            <summary>
            Gets the timestamp of the image used to index it on the symbol server.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.FileName">
            <summary>
            Gets the file name of the module on disk.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.GetPEImage">
            <summary>
            Returns a <see cref="T:Microsoft.Diagnostics.Runtime.Utilities.PEImage"/> from a stream constructed using instance fields of this object.
            If the PEImage cannot be constructed, <see langword="null"/> is returned.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.BuildId">
            <summary>
            Gets the Linux BuildId of this module.  This will be <see langword="null"/> if the module does not have a BuildId.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.IsManaged">
            <summary>
            Gets a value indicating whether the module is managed.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.Pdb">
            <summary>
            Gets the PDB associated with this module.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ModuleInfo.Version">
            <summary>
            Gets the version information for this file.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.#ctor(System.UInt64,System.String,System.Boolean,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Constructor.
            </summary>
            <param name="imageBase">The base of the image as loaded into the virtual address space.</param>
            <param name="fileName">The full path of the file as loaded from disk (if possible), otherwise only the filename.</param>
            <param name="isVirtual">Whether this image is mapped into the virtual address space.  (This is as opposed to a memmap'ed file.)</param>
            <param name="indexFileSize">The index file size used by the symbol server to archive and request this binary.  Only for PEImages (not Elf or Mach-O binaries).</param>
            <param name="indexTimeStamp">The index timestamp used by the symbol server to archive and request this binary.  Only for PEImages (not Elf or Mach-O binaries).</param>
            <param name="buildId">The ELF buildid of this image.  Not valid for PEImages.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ModuleInfo.#ctor(Microsoft.Diagnostics.Runtime.IDataReader,System.UInt64,System.String,System.Boolean,System.Int32,System.Int32,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Constructor.
            </summary>
            <param name="reader">The <see cref="T:Microsoft.Diagnostics.Runtime.IDataReader"/> containing this module.</param>
            <param name="imageBase">The base of the image as loaded into the virtual address space.</param>
            <param name="fileName">The full path of the file as loaded from disk (if possible), otherwise only the filename.</param>
            <param name="isVirtual">Whether this image is mapped into the virtual address space.  (This is as opposed to a memmap'ed file.)</param>
            <param name="indexFileSize">The index file size used by the symbol server to archive and request this binary.  Only for PEImages (not Elf or Mach-O binaries).</param>
            <param name="indexTimeStamp">The index timestamp used by the symbol server to archive and request this binary.  Only for PEImages (not Elf or Mach-O binaries).</param>
            <param name="buildId">The ELF buildid of this image.  Not valid for PEImages.</param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ObjectSet">
            <summary>
            This class is a HashSet of ulong for object addresses.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ObjectSet.Heap">
            <summary>
            The ClrHeap this is an object set over.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ObjectSet.MinObjSize">
            <summary>
            The minimum object size for this particular heap.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ObjectSet.Segments">
            <summary>
            The collection of segments and associated objects.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ObjectSet.Count">
            <summary>
            Gets or sets the count of objects in this set.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ObjectSet.#ctor(Microsoft.Diagnostics.Runtime.ClrHeap)">
            <summary>
            Constructor.
            </summary>
            <param name="heap">A ClrHeap to add objects from.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ObjectSet.Contains(System.UInt64)">
            <summary>
            Returns true if this set contains the given object, false otherwise.  The behavior of this function is undefined if
            obj lies outside the GC heap.
            </summary>
            <param name="obj">The object to check.</param>
            <returns>True if this set contains the given object, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ObjectSet.Add(System.UInt64)">
            <summary>
            Adds the given object to the set.  Returns true if the object was added to the set, returns false if the object was already in the set.
            </summary>
            <param name="obj">The object to add to the set.</param>
            <returns>True if the object was added to the set, returns false if the object was already in the set.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ObjectSet.Remove(System.UInt64)">
            <summary>
            Removes the given object from the set.  Returns true if the object was removed, returns false if the object was not in the set.
            </summary>
            <param name="obj">The object to remove from the set.</param>
            <returns>True if the object was removed, returns false if the object was not in the set.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ObjectSet.Clear">
            <summary>
            Empties the set.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ObjectSet.GetOffset(System.UInt64,Microsoft.Diagnostics.Runtime.ObjectSet.HeapHashSegment)">
            <summary>
            Calculates the offset of an object within a segment.
            </summary>
            <param name="obj">The object.</param>
            <param name="seg">The segment.</param>
            <returns>The index into seg.Objects.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ObjectSet.GetSegment(System.UInt64,Microsoft.Diagnostics.Runtime.ObjectSet.HeapHashSegment@)">
            <summary>
            Gets the segment for the given object.
            </summary>
            <param name="obj">The object in question.</param>
            <param name="seg">The resulting segment.</param>
            <returns>True if obj lies within a gc segment, false otherwise.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ObjectSet.HeapHashSegment">
            <summary>
            A segment of memory in the heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ObjectSet.HeapHashSegment.Objects">
            <summary>
            The objects in the memory range.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ObjectSet.HeapHashSegment.StartAddress">
            <summary>
            The start address of the segment.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ObjectSet.HeapHashSegment.EndAddress">
            <summary>
            The end address of the segment.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.PdbInfo">
            <summary>
            Information about a specific PDB instance obtained from a PE image.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.Guid">
            <summary>
            Gets the Guid of the PDB.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.Revision">
            <summary>
            Gets the PDB revision.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.PdbInfo.Path">
            <summary>
            Gets the path to the PDB.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PdbInfo.#ctor(System.String,System.Guid,System.Int32)">
            <summary>
            Creates an instance of the PdbInfo class with the corresponding properties initialized.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PdbInfo.GetHashCode">
            <summary>
            GetHashCode implementation.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PdbInfo.Equals(System.Object)">
            <summary>
            Override for Equals.  Returns true if the guid, age, and file names equal.  Note that this compares only the.
            </summary>
            <param name="obj"></param>
            <returns>True if the objects match, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PdbInfo.ToString">
            <summary>
            To string implementation.
            </summary>
            <returns>Printing friendly version.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper">
            <summary>
            Helper for Runtime Callable Wrapper objects.  (RCWs are COM objects which are exposed to the runtime
            as managed objects.)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.IUnknown">
            <summary>
            Gets the pointer to the IUnknown representing this CCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.VTablePointer">
            <summary>
            Gets the external VTable associated with this RCW.  (It's useful to resolve the VTable as a symbol
            which will tell you what the underlying native type is...if you have the symbols for it loaded).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.RefCount">
            <summary>
            Gets the RefCount of the RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.Object">
            <summary>
            Gets the managed object associated with this of RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.IsDisconnected">
            <summary>
            Gets a value indicating whether the RCW is disconnected from the underlying COM type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.CreatorThread">
            <summary>
            Gets the thread which created this RCW.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.WinRTObject">
            <summary>
            Gets the internal WinRT object associated with this RCW (if one exists).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RuntimeCallableWrapper.Interfaces">
            <summary>
            Gets the list of interfaces this RCW implements.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.StringCaching.None">
            <summary>
            Do not cache the value at all.  This will result in drastically lower memory
            usage at the cost of performance.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.StringCaching.Cache">
            <summary>
            Strings will be cached by the objects which hold them.  This will make repeated
            requests to get the same value MUCH faster, but at the cost of holding on to
            extra memory.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.StringCaching.Intern">
            <summary>
            Strings will be cached by the objects which hold them and they will also be
            interned, ensuring that the same string value will not be kept alive by multiple
            objects.  The danger here is that interned strings are never freed until the
            AppDomain they live in is unloaded (or never for .NET Core).  Field names will
            benefit from interning if you read a lot of fields for a lot of types.  It's
            unlikely that method names or type names will benefit from interning unless
            the same types are loaded into multiple AppDomains in the target process.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.VersionInfo">
            <summary>
            Represents the version of a DLL.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.VersionInfo.Major">
            <summary>
            In a version 'A.B.C.D', this field represents 'A'.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.VersionInfo.Minor">
            <summary>
            In a version 'A.B.C.D', this field represents 'B'.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.VersionInfo.Revision">
            <summary>
            In a version 'A.B.C.D', this field represents 'C'.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.VersionInfo.Patch">
            <summary>
            In a version 'A.B.C.D', this field represents 'D'.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.VersionInfo.Equals(Microsoft.Diagnostics.Runtime.VersionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.VersionInfo.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.VersionInfo.GetHashCode">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.VersionInfo.CompareTo(Microsoft.Diagnostics.Runtime.VersionInfo)">
            <inheritdoc/>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.VersionInfo.ToString">
            <summary>
            To string.
            </summary>
            <returns>The A.B.C.D version prepended with 'v'.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress">
            <summary>
            A representation of CLR's CLRDATA_ADDRESS, which is a signed 64bit integer.
            Unfortunately this can cause issues when inspecting 32bit processes, since
            if the highest bit is set the value will be sign-extended.  This struct is
            meant to
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress.Value">
            <summary>
            Gets raw value of this address.  May be sign-extended if inspecting a 32bit process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress.#ctor(System.Int64)">
            <summary>
            Creates an instance of ClrDataAddress.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress.op_Implicit(Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress)~System.UInt64">
            <summary>
            Returns the value of this address and un-sign extends the value if appropriate.
            </summary>
            <param name="cda">The address to convert.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataAddress.AsUInt64">
            <summary>
            Returns the value of this address and un-sign extends the value if appropriate.
            </summary>
            <returns>The value of this address and un-sign extends the value if appropriate.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.ClrDataProcess">
            <summary>
            This is an undocumented, untested, and unsupported interface.  Do not use.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.SOSDac">
            <summary>
            This is an undocumented, untested, and unsupported interface.  Do not use.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.SOSDac6">
            <summary>
            This is an undocumented, untested, and unsupported interface.  Do not use.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInterface.SOSDac8">
            <summary>
            This is an undocumented, untested, and unsupported interface.  Do not use.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.CoredumpReader.TryGetSymbolAddress(System.UInt64,System.String,System.UInt64@)">
            <summary>
            Returns the address of a module export symbol if found
            </summary>
            <param name="baseAddress">module base address</param>
            <param name="name">symbol name (without the module name prepended)</param>
            <param name="offset">address returned</param>
            <returns>true if found</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.IDataReader">
            <summary>
            An interface for reading data out of the target process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.DisplayName">
            <summary>
            The name of the target.  This should be a meaningful moniker such as the pid of the target
            process or the path to the dump being read.  This is primarily used when debugging to see
            what DataTarget is inspecting.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.IsThreadSafe">
            <summary>
            Gets a value indicating whether this data reader is safe to use in parallel from multiple threads.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.TargetPlatform">
            <summary>
            The platform that the target process was running on.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.Architecture">
            <summary>
            Gets the architecture of the target.
            </summary>
            <returns>The architecture of the target.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IDataReader.ProcessId">
            <summary>
            Gets the process ID of the DataTarget.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.EnumerateModules">
            <summary>
            Enumerates modules in the target process.
            </summary>
            <returns>An enumerable of the modules in the target process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetBuildId(System.UInt64)">
            <summary>
            Returns the BuildId of a native Elf file.
            </summary>
            <param name="baseAddress"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetVersionInfo(System.UInt64,Microsoft.Diagnostics.Runtime.VersionInfo@)">
            <summary>
            Gets the version information for a given module (given by the base address of the module).
            </summary>
            <param name="baseAddress">The base address of the module to look up.</param>
            <param name="version">The version info for the given module.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.GetThreadContext(System.UInt32,System.UInt32,System.Span{System.Byte})">
            <summary>
            Gets the thread context for the given thread.
            </summary>
            <param name="threadID">The OS thread ID to read the context from.</param>
            <param name="contextFlags">The requested context flags, or 0 for default flags.</param>
            <param name="context">A span to write the context to.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IDataReader.FlushCachedData">
            <summary>
            Informs the data reader that the user has requested all data be flushed.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.IExportReader">
            <summary>
            Module export symbol reader
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IExportReader.TryGetSymbolAddress(System.UInt64,System.String,System.UInt64@)">
            <summary>
            Returns the address of a module export symbol if found
            </summary>
            <param name="baseAddress">module base address</param>
            <param name="name">symbol name (without the module name prepended)</param>
            <param name="offset">address returned</param>
            <returns>true if found</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.IMemoryReader.PointerSize">
            <summary>
            Gets the size of a pointer in the target process.
            </summary>
            <returns>The pointer size of the target process.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IMemoryReader.Read(System.UInt64,System.Span{System.Byte})">
            <summary>
            Read memory out of the target process.
            </summary>
            <param name="address">The address of memory to read.</param>
            <param name="buffer">The buffer to write to.</param>
            <returns>The number of bytes read into the buffer.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IMemoryReader.Read``1(System.UInt64,``0@)">
            <summary>
            Read an unmanaged value from the given address.
            </summary>
            <typeparam name="T">The type to read.  This may be a struct or primitive type as long as it does
            not managed pointers.</typeparam>
            <param name="address">The address to read from.</param>
            <param name="value">The value that was read.</param>
            <returns>True if the memory was present, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IMemoryReader.Read``1(System.UInt64)">
            <summary>
            Read an unmanaged value from the given address.  Returns default(T) if the data was not readable.
            </summary>
            <typeparam name="T">The type to read.  This may be a struct or primitive type as long as it does
            not managed pointers.</typeparam>
            <param name="address">The address to read from.</param>
            <returns>The value at addr, or default(T) if not present in the data target.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IMemoryReader.ReadPointer(System.UInt64,System.UInt64@)">
            <summary>
            Reads a pointer at the given address.
            </summary>
            <param name="address">The address to read from.</param>
            <param name="value">A pointer sized value that was read.</param>
            <returns>True if the value was read, false if the value could not be read.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IMemoryReader.ReadPointer(System.UInt64)">
            <summary>
            Read a pointer out of the target process.
            </summary>
            <returns>
            The pointer at the give address, or 0 if that pointer doesn't exist in
            the data target.
            </returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DataReaders.Implementation.IThreadReader">
            <summary>
            This interface is implemented by all ClrMD provided implementations of <see cref="T:Microsoft.Diagnostics.Runtime.IDataReader"/>.
            This interface is not used by the ClrMD library itself, but is here to maintain functionality
            for previous uses of these functions in ClrMD 1.1's <see cref="T:Microsoft.Diagnostics.Runtime.IDataReader"/>.
            
            This inteface must always be requested and not assumed to be there:
            
                IDataReader reader = ...;
            
                if (reader is IThreadReader threadReader)
                    ...
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataReaders.Implementation.IThreadReader.EnumerateOSThreadIds">
            <summary>
            Enumerates the thread ids of all live threads in the target process.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataReaders.Implementation.IThreadReader.GetThreadTeb(System.UInt32)">
            <summary>
            Obtains the Windows specific Thread Execution Block.
            </summary>
            <param name="osThreadId"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Arm64Context">
            <summary>
            ARM-specific thread context.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ArmContext">
            <summary>
            ARM-specific thread context.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Float80">
            <summary>
            Float in X86-specific windows thread context.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RegisterAttribute.Name">
            <summary>
            Gets or sets optional name override
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.RegisterAttribute.RegisterType">
            <summary>
            Gets register type and flags
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.X86Context">
            <summary>
            X86-specific windows thread context.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrFlavor">
            <summary>
            Returns the "flavor" of CLR this module represents.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrFlavor.Desktop">
            <summary>
            This is the full version of CLR included with windows.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.ClrFlavor.Core">
            <summary>
            For .NET Core
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInfo">
            <summary>
            Represents information about a single CLR in a process.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.Version">
            <summary>
            Gets the version number of this runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.Flavor">
            <summary>
            Gets the type of CLR this module represents.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.DacInfo">
            <summary>
            Gets module information about the DAC needed create a <see cref="T:Microsoft.Diagnostics.Runtime.ClrRuntime"/> instance for this runtime.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.ModuleInfo">
            <summary>
            Gets module information about the ClrInstance.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.ClrInfo.SingleFileRuntimeInfo">
            <summary>
            If the application is single-file, this contains the runtime, DAC and DBI index information
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.ToString">
            <summary>
            To string.
            </summary>
            <returns>A version string for this CLR.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfo.CreateRuntime(System.String,System.Boolean)">
            <summary>
            Creates a runtime from the given DAC file on disk.
            </summary>
            <param name="dacPath">A full path to the matching DAC dll for this process.</param>
            <param name="ignoreMismatch">Whether or not to ignore mismatches between. </param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.ClrInfoProvider">
            <summary>
            Infers clr info from module names, provides corresponding DAC details.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfoProvider.IsSupportedRuntime(Microsoft.Diagnostics.Runtime.ModuleInfo,Microsoft.Diagnostics.Runtime.ClrFlavor@,System.Runtime.InteropServices.OSPlatform@)">
            <summary>
            Checks if the provided module corresponds to a supported runtime, gets clr details inferred from the module name.
            </summary>
            <param name="moduleInfo">Module info.</param>
            <param name="flavor">CLR flavor.</param>
            <param name="platform">Platform.</param>
            <returns>true if module corresponds to a supported runtime.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfoProvider.GetDacFileName(Microsoft.Diagnostics.Runtime.ClrFlavor,System.Runtime.InteropServices.OSPlatform)">
            <summary>
            Returns the file name of the DAC dll according to the specified parameters.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.ClrInfoProvider.GetDacRequestFileName(Microsoft.Diagnostics.Runtime.ClrFlavor,Microsoft.Diagnostics.Runtime.Architecture,Microsoft.Diagnostics.Runtime.Architecture,Microsoft.Diagnostics.Runtime.VersionInfo,System.Runtime.InteropServices.OSPlatform)">
            <summary>
            Returns the file name of the DAC dll for the requests to the symbol server.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.CustomDataTarget">
            <summary>
            A user-defined data reader.
            Note that this class will be kept alive by <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> until <see cref="M:Microsoft.Diagnostics.Runtime.DataTarget.Dispose"/>
            is called.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.DataReader">
            <summary>
            The data reader that ClrMD will use to read data from the target.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.CacheOptions">
            <summary>
             An optional set of cache options.  Returning null from this property will use ClrMD's default
             cache options.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.BinaryLocator">
            <summary>
            An optional binary locator.  Returning null from this property will use ClrMD's default binary
            locator, which uses either <see cref="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.DefaultSymbolPath"/> (if non null) or the _NT_SYMBOL_PATH (if
            <see cref="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.DefaultSymbolPath"/> is null) environment variable to search for missing binaries.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.DefaultSymbolPath">
            <summary>
            If <see cref="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.BinaryLocator"/> is null, this path will be used as the symbol path for the default
            binary locator.  This property has no effect if <see cref="P:Microsoft.Diagnostics.Runtime.CustomDataTarget.BinaryLocator"/> is non-null.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.CustomDataTarget.#ctor(Microsoft.Diagnostics.Runtime.IDataReader)">
            <summary>
            Constructor.
            </summary>
            <param name="reader">A non-null IDataReader.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.CustomDataTarget.Dispose">
            <summary>
            Dispose method.  Called when <see cref="M:Microsoft.Diagnostics.Runtime.DataTarget.Dispose"/> is called.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.CustomDataTarget.Dispose(System.Boolean)">
            <summary>
            Dispose implementation.  The default implementation will call Dispose() on DataReader if
            it implements IDisposable.
            </summary>
            <param name="disposing"></param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DacInfo">
            <summary>
            This class provides information needed to located the correct CLR diagnostics DLL (this dll
            is called the Debug Access Component (DAC)).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInfo.LocalDacPath">
            <summary>
            If a local dac exists on disk that matches this dac, this property will contain its full path.
            In a live debugging scenario this will almost always point to a local dac which can be used to inspect
            the process (unless the user deleted mscordaccore in the .Net Core case).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInfo.PlatformSpecificFileName">
            <summary>
            Gets the platform specific filename of the DAC dll.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInfo.PlatformAgnosticFileName">
            <summary>
            Gets the platform-agnostic file name of the DAC dll.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInfo.TargetArchitecture">
            <summary>
            Gets the architecture (x86 or amd64) being targeted.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInfo.IndexFileSize">
            <summary>
            Gets the specific file size of the image used to index it on the symbol server.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInfo.IndexTimeStamp">
            <summary>
            Gets the timestamp of the image used to index it on the symbol server.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInfo.Version">
            <summary>
            Gets the version information for the CLR this dac matches.  The dac will have the
            same version.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DacInfo.ClrBuildId">
            <summary>
            If CLR has a build id on this platform, this property will contain its build id.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DacInfo.#ctor(System.String,System.String,System.String,Microsoft.Diagnostics.Runtime.Architecture,System.Int32,System.Int32,Microsoft.Diagnostics.Runtime.VersionInfo,System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Constructs a DacInfo object with the appropriate properties initialized.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.DataTarget">
            <summary>
            A crash dump or live process to read out of.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.DataReader">
            <summary>
            Gets the data reader for this instance.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.CacheOptions">
            <summary>
            The caching options for ClrMD.  This controls what kinds of memory we cache and what values have to be
            recalculated on every call.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.BinaryLocator">
            <summary>
            Gets or sets instance to manage the symbol path(s).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.#ctor(Microsoft.Diagnostics.Runtime.CustomDataTarget)">
            <summary>
            Creates a DataTarget from the given reader.
            </summary>
            <param name="customTarget">The custom data target to use.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.ClrVersions">
            <summary>
            Gets the list of CLR versions loaded into the process.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.EnumerateModules">
            <summary>
            Enumerates information about the loaded modules in the process (both managed and unmanaged).
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.DataTarget.PlatformFunctions">
            <summary>
            Gets a set of helper functions that are consistently implemented across all platforms.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.LoadDump(System.String,System.IO.Stream,Microsoft.Diagnostics.Runtime.CacheOptions,System.Boolean)">
            <summary>
            Loads a dump stream. Currently supported formats are ELF coredump and Windows Minidump formats.
            </summary>
            <param name="displayName">The name of this DataTarget, might be used in exceptions.</param>
            <param name="stream">The stream that should be used.</param>
            <param name="cacheOptions">The caching options to use. (Only used for FileStreams)</param>
            <param name="leaveOpen">True whenever the given stream should be leaved open when the DataTarget is disposed.</param>
            <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> for the given dump.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.LoadDump(System.String,Microsoft.Diagnostics.Runtime.CacheOptions)">
            <summary>
            Loads a dump file. Currently supported formats are ELF coredump and Windows Minidump formats.
            </summary>
            <param name="filePath">The path to the dump file.</param>
            <param name="cacheOptions">The caching options to use.</param>
            <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> for the given dump file.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.AttachToProcess(System.Int32,System.Boolean)">
            <summary>
            Attaches to a running process.  Note that if <paramref name="suspend"/> is set to false the user
            of ClrMD is still responsible for suspending the process itself.  ClrMD does NOT support inspecting
            a running process and will produce undefined behavior when attempting to do so.
            </summary>
            <param name="processId">The ID of the process to attach to.</param> 
            <param name="suspend">Whether or not to suspend the process.</param>
            <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateSnapshotAndAttach(System.Int32)">
            <summary>
            Creates a snapshot of a running process and attaches to it.  This method will pause a running process
            
            </summary>
            <param name="processId">The ID of the process to attach to.</param>
            <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> instance.</returns>
            <exception cref="T:System.ArgumentException">
            The process specified by <paramref name="processId"/> is not running.
            </exception>
            <exception cref="T:System.PlatformNotSupportedException">
            The current platform is not Windows.
            </exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.DataTarget.CreateFromDbgEng(System.IntPtr)">
            <summary>
            Creates a DataTarget from an IDebugClient interface.  This allows callers to interop with the DbgEng debugger
            (cdb.exe, windbg.exe, dbgeng.dll).
            </summary>
            <param name="pDebugClient">An IDebugClient interface.</param>
            <returns>A <see cref="T:Microsoft.Diagnostics.Runtime.DataTarget"/> instance.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.IAddressableTypedEntityExtensions.GetFieldFrom(Microsoft.Diagnostics.Runtime.IAddressableTypedEntity,System.String)">
            <summary>
            Gets the field value from <see cref="T:Microsoft.Diagnostics.Runtime.IAddressableTypedEntity"/> with respect to field nature (either reference, or value type).
            </summary>
            <param name="entity">The entity to read field value from.</param>
            <param name="fieldName">The name of the field to get value.</param>
            <exception cref="T:System.ArgumentNullException">if entity has no type.</exception>
            <exception cref="T:System.ArgumentException">Thrown when field with matching name was not found.</exception>
            <returns></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.MemorySearcher">
            <summary>
            A public extension methods to support searching an IMemoryReader for a given span.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.MemorySearcher.SearchMemory(Microsoft.Diagnostics.Runtime.IMemoryReader,System.UInt64,System.Int32,System.ReadOnlySpan{System.Byte})">
            <summary>
            Searches memory from startAddress to endAddress, looking for the memory specified by `searchFor`.  Note
            that this is NOT meant to be used to search the entire address space.  This method will attempt to read
            all memory from startAddress to endAddress, so providing very large ranges of memory will make this take
            a long time.
            </summary>
            <param name="reader">The memory reader to search through.</param>
            <param name="startAddress">The address to start searching memory.</param>
            <param name="length">The length of memory to search.</param>
            <param name="searchFor">The memory to search for.</param>
            <returns>The address of the value if found, 0 if not found.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Implementation.ClrmdAppDomain.#ctor(Microsoft.Diagnostics.Runtime.ClrRuntime,Microsoft.Diagnostics.Runtime.Implementation.IAppDomainHelpers,System.UInt64)">
            <summary>
            Create an "empty" ClrAppDomain when we cannot request app domain details.
            </summary>
            <param name="runtime">The containing runtime.</param>
            <param name="helpers">Helpers for querying data</param>
            <param name="address">The address of the AppDomain</param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Implementation.ClrmdGenericType">
            <summary>
            This represents a ClrType for which we cannot get information from the dac.  In theory we shouldn't need this
            type, but in practice there are fields which do not report a type.  This allows us to provide a non-null, semi
            meaningful type even though it's not as accurate or specific as we wish it would be.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Implementation.ClrmdRuntime.GetTypeByMethodTable(System.UInt64)">
            <summary>
            Gets the <see cref="T:Microsoft.Diagnostics.Runtime.ClrType"/> corresponding to the given MethodTable.
            </summary>
            <param name="methodTable">The ClrType.MethodTable for the requested type.</param>
            <returns>A ClrType object, or <see langword="null"/> if no such type exists.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Implementation.ClrmdRuntime.FlushCachedData">
            <summary>
            Flushes the DAC cache.  This function <b>must</b> be called any time you expect to call the same function
            but expect different results.  For example, after walking the heap, you need to call Flush before
            attempting to walk the heap again.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Implementation.HeapWalkStep">
            <summary>
            This struct represents a single step in <see cref="T:Microsoft.Diagnostics.Runtime.Implementation.ClrmdHeap"/>'s heap walk.  This is used for diagnostic purposes.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Implementation.ITypeHelpers.GetTypeName(System.UInt64,System.String@)">
            <summary>
            Gets the name for a type.
            </summary>
            <param name="mt">The MethodTable to request the name of.</param>
            <param name="name">The name for that type, note that this has already had FixGenerics called on it.</param>
            <returns>True if the value should be cached, false if the value should not be cached.  (This is controlled
            by the user's string cache settings.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile">
            <summary>
            A helper class to read linux coredumps.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.ElfFile">
            <summary>
            All coredumps are themselves ELF files.  This property returns the ElfFile that represents this coredump.  
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.EnumeratePRStatus">
            <summary>
            Enumerates all prstatus notes contained within this coredump.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.GetAuxvValue(Microsoft.Diagnostics.Runtime.Utilities.ElfAuxvType)">
            <summary>
            Returns the Auxv value of the given type.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.LoadedImages">
            <summary>
            A mapping of all loaded images in the process.  The key is the base address that the module is loaded at.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.#ctor(System.String)">
            <summary>
            Creates an ElfCoreFile from a file on disk.
            </summary>
            <param name="coredump">A full path to a coredump on disk.</param>
            <exception cref="T:System.IO.InvalidDataException">Throws <see cref="T:System.IO.InvalidDataException"/> if the file is not an Elf coredump.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates an ElfCoreFile from a file on disk.
            </summary>
            <param name="stream">The Elf stream to read the coredump from.</param>
            <param name="leaveOpen">Whether to leave the given stream open after this class is disposed.</param>
            <exception cref="T:System.IO.InvalidDataException">Throws <see cref="T:System.IO.InvalidDataException"/> if the file is not an Elf coredump.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfCoreFile.ReadMemory(System.UInt64,System.Span{System.Byte})">
            <summary>
            Reads memory from the given coredump's virtual address space.
            </summary>
            <param name="address">An address in the target program's virtual address space.</param>
            <param name="buffer">The buffer to fill.</param>
            <returns>The number of bytes written into the buffer.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfFile">
            <summary>
            A helper class to read ELF files.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.Header">
            <summary>
            The ElfHeader of this file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.Notes">
            <summary>
            The list of ElfNotes for this file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.ProgramHeaders">
            <summary>
            The list of ProgramHeaders for this file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.DynamicSection">
            <summary>
            The ELFDynamicSection for this file, if it exists.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.BuildId">
            <summary>
            Returns the build id of this ELF module (or ImmutableArray.Default if it doesn't exist).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.#ctor(System.String)">
            <summary>
            Creates an ElfFile from a file on disk.
            </summary>
            <param name="filename">A full path of an elf file on disk.</param>
            <exception cref="T:System.IO.InvalidDataException">Throws <see cref="T:System.IO.InvalidDataException"/> if the file is not an Elf coredump.</exception>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfFile.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Creates an ElfFile from a file on disk.
            </summary>
            <param name="stream">The Elf stream to read the Elf file from.</param>
            <param name="leaveOpen">Whether to leave the given stream open after this class is disposed.</param>
            <exception cref="T:System.IO.InvalidDataException">Throws <see cref="T:System.IO.InvalidDataException"/> if the file is not an Elf file.</exception>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage">
            <summary>
            A representation of an ELF loaded image section.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.BaseAddress">
            <summary>
            The BaseAddress of this image
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.Size">
            <summary>
            The size of this image in memory.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.Open">
            <summary>
            Open the loaded image as an ELFFile.
            </summary>
            <returns>An ELFFile if this is a valid ELF image, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.AsStream">
            <summary>
            Returns this ELF loaded image as a stream.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.ToString">
            <summary>
            Returns <see cref="P:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.FileName"/>.
            </summary>
            <returns><see cref="P:Microsoft.Diagnostics.Runtime.Utilities.ElfLoadedImage.FileName"/></returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfNote">
            <summary>
            A helper class to represent an ELF note section.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfNote.ContentSize">
            <summary>
            The content size of the data stored within this note.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfNote.Type">
            <summary>
            The type of note this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfNote.Name">
            <summary>
            The note's name.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfNote.ReadContents(System.UInt64,System.Span{System.Byte})">
            <summary>
            Reads the contents of this note file.
            </summary>
            <param name="position">The position within the note to read from.</param>
            <param name="buffer">The buffer to read the note into.</param>
            <returns>The number of bytes read written to buffer.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ElfNote.ReadContents``1(System.UInt64)">
            <summary>
            Reads the contents of this note file.
            </summary>
            <param name="position">The position within the note to read from.</param>
            <exception cref="T:System.IO.IOException">If the data could not be read.</exception>
            <returns>The data at the given position.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader">
            <summary>
            A helper class to represent ELF program headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.Type">
            <summary>
            The type of header this is.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.VirtualAddress">
            <summary>
            The VirtualAddress of this header.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.VirtualSize">
            <summary>
            The size of this header.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.FileOffset">
            <summary>
            The offset of this header within the file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.FileSize">
            <summary>
            The size of this header within the file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.IsExecutable">
            <summary>
            Whether this section of memory is executable.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeader.IsWritable">
            <summary>
            Whether this section of memory is writable.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader">
            <summary>
            An abstract version of 32 and 64 bit ELF headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.Is64Bit">
            <summary>
            Whether this file is 64 bit or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.IsValid">
            <summary>
            Whether this file contains the magic header at the right offset or not.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.Type">
            <summary>
            The type of ELF file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.Architecture">
            <summary>
            The architecture of the ELF file.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.ProgramHeaderOffset">
            <summary>
            The offset of the program header.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.SectionHeaderOffset">
            <summary>
            The offset of the section header.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.ProgramHeaderEntrySize">
            <summary>
            The size of program headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.ProgramHeaderCount">
            <summary>
            The count of program headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.SectionHeaderEntrySize">
            <summary>
            The size of section headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.SectionHeaderCount">
            <summary>
            The count of section headers.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfHeader.SectionHeaderStringIndex">
            <summary>
            The section header string index.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IElfPRStatus">
            <summary>
            An abstraction of the ELF PRStatus view.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfPRStatus.ProcessId">
            <summary>
            The process id associated with this prstatus
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.IElfPRStatus.ThreadId">
            <summary>
            The thread id of this prstatus.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.IElfPRStatus.CopyRegistersAsContext(System.Span{System.Byte})">
            <summary>
            Copies the registers within this prstatus into the Windows _CONTEXT structure for the specified
            architecture.
            
            <see cref="T:Microsoft.Diagnostics.Runtime.Arm64Context"/>
            <see cref="T:Microsoft.Diagnostics.Runtime.AMD64Context"/>
            <see cref="T:Microsoft.Diagnostics.Runtime.ArmContext"/>
            <see cref="T:Microsoft.Diagnostics.Runtime.X86Context"/>
            </summary>
            <param name="context">A span to copy the context into.  This should generally be one of the predefined *Context structs,
            e.g. <see cref="T:Microsoft.Diagnostics.Runtime.AMD64Context"/>.</param>
            <returns>True if the registers were copied to the context, false otherwise.  Usually a return value of false means that
            <paramref name="context"/> was too small.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.LinuxDefaultSymbolLocator">
            <summary>
            A symbol locator that search binaries based on files loaded in the live Linux target.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.LinuxLiveDataReader">
            <summary>
            A data reader that targets a Linux process.
            The current process must have ptrace access to the target process.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfHeaderType">
            <summary>
            The type of ELF file.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfMachine">
            <summary>
            The ELF machine type
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfNoteType">
            <summary>
            The kind of ELF note.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ElfProgramHeaderType">
            <summary>
            The type of program header.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown">
            <summary>
            A class that allows you to build a custom IUnknown based interface to pass as a COM object.
            This class is public to allow others to use this code and not duplicate it, but it is not
            intended for general use.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.IUnknownObject">
            <summary>
            Gets the IUnknown pointer to this object.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.IUnknown">
            <summary>
            Gets the IUnknown VTable for this object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.#ctor">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.AddRef">
            <summary>
            AddRef.
            </summary>
            <returns>The new ref count.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.Release">
            <summary>
            Release.
            </summary>
            <returns>The new RefCount.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.COMCallableIUnknown.AddInterface(System.Guid,System.Boolean)">
            <summary>
            Adds an IUnknown based interface to this COM object.
            </summary>
            <param name="guid">The GUID of this interface.</param>
            <param name="validate">Whether or not to validate the delegates that
            used to build this COM interface's methods.</param>
            <returns>A VTableBuilder to construct this interface.  Note that until VTableBuilder.Complete
            is called, the interface will not be registered.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.COMHelper">
            <summary>
            Base class for COM related objects in ClrMD.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.COMHelper.Release(System.IntPtr)">
            <summary>
            Release an IUnknown pointer.
            </summary>
            <param name="pUnk">A pointer to the IUnknown interface to release.</param>
            <returns>The result of pUnk->Release().</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.HResult.op_Implicit(Microsoft.Diagnostics.Runtime.Utilities.HResult)~System.Int32">
            <summary>
            Helper to convert to int for comparisons.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.HResult.op_Implicit(Microsoft.Diagnostics.Runtime.Utilities.HResult)~System.Boolean">
            <summary>
            This makes "if (hr)" equivalent to SUCCEEDED(hr).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IUnknownVTable">
            <summary>
            The basic VTable for an IUnknown interface.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.VTableBuilder">
            <summary>
            Builds an individual VTable for a COM object.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.VTableBuilder.AddMethod(System.Delegate,System.Boolean)">
            <summary>
            Adds a method to be the next function in the VTable.
            </summary>
            <param name="validate">Whether to validate the delegate matches requirements.</param>
            <param name="func">The function to add to the next slot of the VTable.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.VTableBuilder.Complete">
            <summary>
            Completes the VTable, registering its GUID with the associated COMCallableIUnknown's QueryInterface
            method.  Note that if this method is not called, then the COM interface will NOT be registered.
            </summary>
            <returns>A pointer to the interface built.  This pointer has not been AddRef'ed.</returns>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.Command">
            <summary>
            Command represents a running of a command lineNumber process.  It is basically
            a wrapper over System.Diagnostics.Process, which hides the complexity
            of System.Diagnostics.Process, and knows how to capture output and otherwise
            makes calling commands very easy.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.StartTime">
            <summary>
            Gets the time the process started.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.HasExited">
            <summary>
            Gets a value indicating whether the process has exited.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.ExitTime">
            <summary>
            Gets the time the processed Exited.  (HasExited should be <see langword="true"/> before calling)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Duration">
            <summary>
            Gets the duration of the command (HasExited should be <see langword="true"/> before calling)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Id">
            <summary>
            Gets the operating system ID for the subprocess.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.ExitCode">
            <summary>
            Gets the process exit code for the subprocess.  (HasExited should be <see langword="true"/> before calling)
            Often this does not need to be checked because Command.Run will throw an exception
            if it is not zero.   However it is useful if the CommandOptions.NoThrow property
            was set.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Output">
            <summary>
            Gets the standard output and standard error output from the command.  This
            is accumulated in real time so it can vary if the process is still running.
            This property is NOT available if the CommandOptions.OutputFile or CommandOptions.OutputStream
            is specified since the output is being redirected there.   If a large amount of output is
            expected (> 1Meg), the Run.AddOutputStream(Stream) is recommended for retrieving it since
            the large string is never materialized at one time.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Options">
            <summary>
            Gets that CommandOptions structure that holds all the options that affect
            the running of the command (like Timeout, Input ...)
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Run(System.String,Microsoft.Diagnostics.Runtime.Utilities.CommandOptions)">
            <summary>
            Run 'commandLine' as a subprocess and waits for the command to complete.
            Output is captured and placed in the 'Output' property of the returned Command
            structure.
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.#ctor(System.String,Microsoft.Diagnostics.Runtime.Utilities.CommandOptions)">
            <summary>
            Launch a new command and returns the Command object that can be used to monitor
            the result.  It does not wait for the command to complete, however you
            can call 'Wait' to do that, or use the 'Run' or 'RunToConsole' methods. */
            </summary>
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            <param variable="options">Additional qualifiers that control how the process is run</param>
            <returns>A Command structure that can be queried to determine ExitCode, Output, etc.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.#ctor(System.String)">
            <summary>
            Create a subprocess to run 'commandLine' with no special options.
            <param variable="commandLine">The command lineNumber to run as a subprocess</param>
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Wait">
            <summary>
            Wait for a started process to complete (HasExited will be <see langword="true"/> on return)
            </summary>
            <returns>Wait returns that 'this' pointer.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.ThrowCommandFailure(System.String)">
            <summary>
            Throw a error if the command exited with a non-zero exit code
            printing useful diagnostic information along with the thrown message.
            This is useful when NoThrow is specified, and after post-processing
            you determine that the command really did fail, and an normal
            Command.Run failure was the appropriate action.
            </summary>
            <param name="message">An additional message to print in the throw.</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.Command.Process">
            <summary>
            Gets the underlying process object.  Generally not used.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Kill">
            <summary>
            Kill the process (and any child processes (recursively) associated with the
            running command).   Note that it may not be able to kill everything it should
            if the child-parent' chain is broken by a child that creates a subprocess and
            then dies itself.   This is reasonably uncommon, however.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.Quote(System.String)">
            <summary>
            Put double quotes around 'str' if necessary (handles quotes quotes).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.Command.FindOnPath(System.String)">
            <summary>
            Given a string 'commandExe' look for it on the path the way cmd.exe would.
            Returns <see langword="null"/> if it was not found.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions">
            <summary>
            CommandOptions is a helper class for the Command class.  It stores options
            that affect the behavior of the execution of ETWCommands and is passes as a
            parameter to the constructor of a Command.
            It is useful for these options be on a separate class (rather than
            on Command itself), because it is reasonably common to want to have a set
            of options passed to several commands, which is not easily possible otherwise.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Infinite">
            <summary>
            Can be assigned to the Timeout Property to indicate infinite timeout.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.#ctor">
            <summary>
            CommanOptions holds a set of options that can be passed to the constructor
            to the Command Class as well as Command.Run*.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Clone">
            <summary>
            Return a copy an existing set of command options.
            </summary>
            <returns>The copy of the command options.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoThrow">
            <summary>
            Normally commands will throw if the subprocess returns a non-zero
            exit code.  NoThrow suppresses this.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoThrow">
            <summary>
            Updates the NoThrow property and returns the updated commandOptions.
            <returns>Updated command options</returns>
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Start">
            <summary>
            ShortHand for UseShellExecute and NoWait.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddStart">
            <summary>
            Updates the Start property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.UseShellExecute">
            <summary>
            Normally commands are launched with CreateProcess.  However it is
            also possible use the Shell Start API.  This causes Command to look
            up the executable differently.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddUseShellExecute">
            <summary>
            Updates the Start property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoWindow">
            <summary>
            Indicates that you want to hide any new window created.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoWindow">
            <summary>
            Updates the NoWindow property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.NoWait">
            <summary>
            Indicates that you want don't want to wait for the command to complete.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddNoWait">
            <summary>
            Updates the NoWait property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Elevate">
            <summary>
            Gets or sets a value indicating whether the command must run at elevated Windows privileges (causes a new command window).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddElevate">
            <summary>
            Updates the Elevate property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Timeout">
            <summary>
            By default commands have a 10 minute timeout (600,000 msec), If this
            is inappropriate, the Timeout property can change this.  Like all
            timeouts in .NET, it is in units of milliseconds, and you can use
            CommandOptions.Infinite to indicate no timeout.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddTimeout(System.Int32)">
            <summary>
            Updates the Timeout property and returns the updated commandOptions.
            CommandOptions.Infinite can be used for infinite.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.Input">
            <summary>
            Indicates the string will be sent to Console.In for the subprocess.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddInput(System.String)">
            <summary>
            Updates the Input property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.CurrentDirectory">
            <summary>
            Indicates the current directory the subProcess will have.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddCurrentDirectory(System.String)">
            <summary>
            Updates the CurrentDirectory property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.OutputFile">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a archiveFile rather than being stored in Memory in the 'Output' property of the
            command.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddOutputFile(System.String)">
            <summary>
            Updates the OutputFile property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.OutputStream">
            <summary>
            Indicates the standard output and error of the command should be redirected
            to a a TextWriter rather than being stored in Memory in the 'Output' property
            of the command.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddOutputStream(System.IO.TextWriter)">
            <summary>
            Updates the OutputStream property and returns the updated commandOptions.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.EnvironmentVariables">
            <summary>
            Gets the Environment variables that will be set in the subprocess that
            differ from current process's environment variables.  Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath".
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.CommandOptions.AddEnvironmentVariable(System.String,System.String)">
            <summary>
            Adds the environment variable with the give value to the set of
            environment variables to be passed to the sub-process and returns the
            updated commandOptions.   Any time a string
            of the form %VAR% is found in a value of a environment variable it is
            replaced with the value of the environment variable at the time the
            command is launched.  This is useful for example to update the PATH
            environment variable eg. "%PATH%;someNewPath".
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo">
            <summary>
            FileVersionInfo represents the extended version formation that is optionally placed in the PE file resource area.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo.FileVersion">
            <summary>
            Gets the version string
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo.VersionInfo">
            <summary>
            Gets the version of this module
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.FileVersionInfo.Comments">
            <summary>
            Gets comments to supplement the file version
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IMAGE_RESOURCE_DATA_ENTRY">
            <summary>
            Each resource data entry describes a leaf node in the resource directory
            tree.  It contains an offset, relative to the beginning of the resource
            directory of the data for the resource, a size field that gives the number
            of bytes of data at that offset, a CodePage that should be used when
            decoding code point values within the resource data.  Typically for new
            applications the code page would be the Unicode code page.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IMAGE_RESOURCE_DIRECTORY">
            <summary>
            Resource directory consists of two counts, following by a variable length
            array of directory entries.  The first count is the number of entries at
            beginning of the array that have actual names associated with each entry.
            The entries are in ascending order, case insensitive strings.  The second
            count is the number of entries that immediately follow the named entries.
            This second count identifies the number of entries that have 16-bit integer
            Ids as their name.  These entries are also sorted in ascending order.
            This structure allows fast lookup by either name or number, but for any
            given resource entry only one form of lookup is supported, not both.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.IMAGE_RESOURCE_DIRECTORY_ENTRY">
            <summary>
            Each directory contains the 32-bit Name of the entry and an offset,
            relative to the beginning of the resource directory of the data associated
            with this directory entry.  If the name of the entry is an actual text
            string instead of an integer Id, then the high order bit of the name field
            is set to one and the low order 31-bits are an offset, relative to the
            beginning of the resource directory of the string, which is of type
            IMAGE_RESOURCE_DIRECTORY_STRING.  Otherwise the high bit is clear and the
            low-order 16-bits are the integer Id that identify this resource directory
            entry. If the directory entry is yet another resource directory (i.e. a
            subdirectory), then the high order bit of the offset field will be
            set to indicate this.  Otherwise the high bit is clear and the offset
            field points to a resource data entry.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.PEImage">
            <summary>
            A class to read information out of PE images (dll/exe).
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEImage.#ctor(System.IO.Stream,System.Boolean)">
            <summary>
            Constructs a PEImage class for a given PE image (dll/exe) on disk.
            </summary>
            <param name="stream">A Stream that contains a PE image at its 0th offset.  This stream must be seekable.</param>
            <param name="leaveOpen">Whether or not to leave the stream open, if this is set to false stream will be
            disposed when this object is.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEImage.#ctor(System.IO.Stream,System.Boolean,System.Boolean)">
            <summary>
            Constructs a PEImage class for a given PE image (dll/exe) in memory.
            </summary>
            <param name="stream">A Stream that contains a PE image at its 0th offset.  This stream must be seekable.</param>
            <param name="leaveOpen">Whether or not to leave the stream open, if this is set to false stream will be
            disposed when this object is.</param>
            <param name="isVirtual">Whether stream points to a PE image mapped into an address space (such as in a live process or crash dump).</param>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.Resources">
            <summary>
            Gets the root resource node of this PEImage.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.IsValid">
            <summary>
            Gets a value indicating whether the given Stream contains a valid DOS header and PE signature.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.IsPE64">
            <summary>
            Gets a value indicating whether this image is for a 64bit processor.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.IsManaged">
            <summary>
            Gets a value indicating whether this image is managed. (.NET image)
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.IndexTimeStamp">
            <summary>
            Gets the timestamp that this PE image is indexed under.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.IndexFileSize">
            <summary>
            Gets the file size that this PE image is indexed under.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.CorHeader">
            <summary>
            Gets the managed header information for this image.  Undefined behavior if IsValid is <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.CoffHeader">
            <summary>
            Gets a wrapper over this PE image's IMAGE_FILE_HEADER structure.  Undefined behavior if IsValid is <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.PEHeader">
            <summary>
            Gets a wrapper over this PE image's IMAGE_OPTIONAL_HEADER.  Undefined behavior if IsValid is <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.Sections">
            <summary>
            Gets a collection of IMAGE_SECTION_HEADERs in the PE image.  Undefined behavior if IsValid is <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.Pdbs">
            <summary>
            Gets a list of PDBs associated with this PE image.  PE images can contain multiple PDB entries,
            but by convention it's usually the last entry that is the most up to date.  Unless you need to enumerate
            all PDBs for some reason, you should use DefaultPdb instead.
            Undefined behavior if IsValid is <see langword="false"/>.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.PEImage.DefaultPdb">
            <summary>
            Gets the PDB information for this module.  If this image does not contain PDB info (or that information
            wasn't included in Stream) this returns <see langword="null"/>.  If multiple PDB streams are present, this method returns the
            last entry.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEImage.RvaToOffset(System.Int32)">
            <summary>
            Allows you to convert between a virtual address to a stream offset for this module.
            </summary>
            <param name="virtualAddress">The address to translate.</param>
            <returns>The position in the stream of the data, -1 if the virtual address doesn't map to any location of the PE image.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEImage.Read(System.Int32,System.Span{System.Byte})">
            <summary>
            Reads data out of PE image into a native buffer.
            </summary>
            <param name="virtualAddress">The address to read from.</param>
            <param name="dest">The location to write the data.</param>
            <returns>The number of bytes actually read from the image and written to dest.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.PEImage.GetFileVersionInfo">
            <summary>
            Gets the File Version Information that is stored as a resource in the PE file.  (This is what the
            version tab a file's property page is populated with).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry">
            <summary>
            An entry in the resource table.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.MaxChildrenCount">
            <summary>
            The maximum number of children nodes that ResourceEntry objects will consider.  Note that if a PEImage is
            corrupted or if we read bad data out of the target then we may misinterpret the data we read and spend
            a lot of time enumerating bad resources.  Setting this to int.MaxValue removes this limitation.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.MaxNameLength">
            <summary>
            The maximum length ResourceEntry.Name strings we will return.  Note that if a PEImage is
            corrupted or if we read bad data out of the target then we may misinterpret the data we read and spend
            a lot of time enumerating bad resources.  Setting this to int.MaxValue removes this limitation.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Image">
            <summary>
            Gets the PEImage containing this ResourceEntry.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Parent">
            <summary>
            Gets the parent resource of this ResourceEntry.  Null if and only if this is the root node.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Name">
            <summary>
            Gets resource Name.  May be <see langword="null"/> if this is the root node.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.IsLeaf">
            <summary>
            Gets a value indicating whether this is a leaf, and contains data.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Size">
            <summary>
            Gets the size of data for this node.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.ChildCount">
            <summary>
            Gets the number of children this entry contains.  Note that ResourceEntry.Children is capped at
            MaxChildrenCount entries.  This property returns the total number of entries as defined by the
            IMAGE_RESOURCE_DIRECTORY.  That means this number may be larger than Children.Count.
            </summary>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Item(System.String)">
            <summary>
            Returns the given resource child by name.
            </summary>
            <param name="name">The name of the child to return.</param>
            <returns>The child in question, or <see langword="null"/> if none are found with that name.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.GetData(System.Span{System.Byte})">
            <summary>
            The data associated with this entry.
            </summary>
            <returns>A byte array of the data, or a byte[] of length 0 if this entry contains no data.</returns>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.GetData``1(System.Int32)">
            <summary>
            A convenience function to get structured data out of this entry.
            </summary>
            <typeparam name="T">A struct type to convert.</typeparam>
            <param name="offset">The offset into the data.</param>
            <returns>The struct that was read out of the data section.</returns>
        </member>
        <member name="P:Microsoft.Diagnostics.Runtime.Utilities.ResourceEntry.Children">
            <summary>
            Gets the children resources of this ResourceEntry.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.PlatformFunctions">
            <summary>
            A set of helper functions that are consistently implemented across platforms.
            </summary>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PlatformFunctions.LoadLibrary(System.String)">
            <param name="libraryPath">The path to the native library to be loaded.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PlatformFunctions.FreeLibrary(System.IntPtr)">
            <param name="handle">The native library OS handle to be freed.</param>
        </member>
        <member name="M:Microsoft.Diagnostics.Runtime.PlatformFunctions.GetLibraryExport(System.IntPtr,System.String)">
            <param name="handle">The native library OS handle.</param>
            <param name="name">The name of the exported symbol.</param>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Windows.ArrayPoolBasedCacheEntry">
            <summary>
            Represents heap segment cache entries backed by arrays from ArrayPool{byte}.Shared. This technology is less efficient than the <see cref="T:Microsoft.Diagnostics.Runtime.Windows.AWEBasedCacheEntry"/> but it has upsides
            around not requiring special privileges and mapping in a more granular fashion (4k pages vs 64k pages).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Windows.AWEBasedCacheEntry">
            <summary>
            Represents heap segment cache entries backed by AWE (Address Windowing Extensions). This technology allows us to read the entirety of the heap data out of the dump (which is very fast disk
            access wise) up front, keep it in physical memory, but only maps those physical memory pages into our VM space as needed, allowing us to control how much memory we use and making 'mapping in'
            very fast(some page table entry work in Windows instead of physically reading the data off of disk). The downside is it requires the user have special privileges as well as it maps data 
            in 64k chunks(the VirtualAlloc allocation granularity).
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Windows.CacheEntryBase`1">
            <summary>
            This class acts as the base of the two (ArrayPool and AWE) cache entry types.
            </summary>
            <typeparam name="T">The type of data the cache pages hold</typeparam>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.CacheTechnology.ArrayPool">
            <summary>
            Indicates the cache should operate using the ArrayPool to managed byte[] of memory from the dump heap.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.CacheTechnology.AWE">
            <summary>
            Indicates the cache should operate using AWE (Address Windowing Extensions) to manage memory from the dump heap
            </summary>
            <remarks>NOTE: This option is ONLY possible if the user has the 'Lock Pages in Memory' permission, otherwise we will fall back on using <see cref="F:Microsoft.Diagnostics.Runtime.Windows.CacheTechnology.ArrayPool"/></remarks>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.PageInDataEventStart">
            <summary>
            The event ID for when the cache starts paging in data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.PageInDataEventFailed">
            <summary>
            The event ID for when the cache failed while paging in data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.PageInDataEventEnd">
            <summary>
            The event ID for when the cache completes paging in data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.PageOutDataEventStart">
            <summary>
            The event ID for when the cache starts paging out data.
            </summary>
        </member>
        <member name="F:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.PageOutDataEventEnd">
            <summary>
            The event ID for when the cache finishes paging out data.
            </summary>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.Tasks">
            <summary>
            Names of constants in this class make up the middle term in the event name
            E.g.: HeapSegmentCacheProvider/PageInData/Start.
            </summary>
            <remarks>Name of this class is important for EventSource.</remarks>
        </member>
        <member name="T:Microsoft.Diagnostics.Runtime.Windows.HeapSegmentCacheEventSource.Tags">
            <summary>
            Tags describing the event result
            </summary>
            <remarks>Name of this class is important for EventSource.</remarks>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>, the parameter will not be null even if the corresponding type allows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>Initializes the attribute with the specified return value condition.</summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>Gets the return value condition.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>Initializes the attribute with the associated parameter name.</summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
    </members>
</doc>
